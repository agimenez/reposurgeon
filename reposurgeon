#!/usr/bin/env python
#
# rs - a repository surgeon.
#
# By ESR, October 2010.  BSD terms apply.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile
import readline, time, re, email.message, email.parser
import signal, shutil

# TO DO
#
# * Implement delete, expunge, coalesce, spawn to Emacs edit.
#
# * Sanity checking - dangling marks etc.
#
# * Test hg and bzr methods.
#
# * Validity check in edit_in to ensure we have the right type.
#   Should catch the common case where we feed edit_in an out-of date
#   mailbox, so it inflicts a comment change meant for something in the
#   tag list on a commit comment.

# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
             "git fast-export -M -C --all >%s",
             "git init",
             "git fast-import <%s",
             "git checkout",
             "gitk"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
            "hg-fast-export.sh %s",   # Not part of stock hg
            "hg init",
            "hg fast-import %s",      # Not part of stock hg
            "hg checkout",
            "hg view"),
    "bzr" : (".bzr",
             "bzr-fast-export --plain %s",
             "bzr init",
             "bzr fast-import %s",
             "bzr checkout",
             None),    # FIXME: there probably is something...
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

def iso8601_from_unixtime(secs_since_epoch, tzoff=""):
    "Make an ISO8601 timestamp frm Unix time."
    return time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime(secs_since_epoch)) + tzoff

def rfc822_from_unixtime(secs_since_epoch, tzoff=""):
    "Make an RFC822 timestamp from Unix time."
    if tzoff:
        tzoff = " " + tzoff
    return time.strftime("%a %d %b %Y %H:%M:%S", time.gmtime(secs_since_epoch)) + tzoff

class RepoSurgeonEmail(email.message.Message):
    "Specialized email message with a distinguishing starter."
    def __init__(self, **kwargs):
        email.message.Message.__init__(self, **kwargs)        
        self.set_unixfrom(78 * "-")
    @staticmethod
    def readmsg(fp):
        msg = ''
        firstline = fp.readline()
        if not firstline:
            return None
        elif not firstline.startswith(78 * "-"):
            msg = firstline
        while True:
            line = fp.readline()
            if not line:
                break
            if line.startswith(78 * "-"):
                break
            msg += line
        return msg

    def __str__(self):
        return email.message.Message.__str__(self).replace("\n--", "\n.--")

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def isodate(self):
        "Return ISO format for time/date of this action."
        timeout = self.when
        if self.when[0].isdigit():
            (unixtime, tzoff) = self.when.split()
            timeout = iso8601_from_unixtime(int(unixtime), tzoff)
        return timeout
    def rfc822date(self):
        "Return RFC822 format for time/date of this action."
        timeout = self.when
        if self.when[0].isdigit():
            (unixtime, tzoff) = self.when.split()
            timeout = rfc822_from_unixtime(int(unixtime), tzoff)
        return timeout
    def email_out(self, msg, hdr):
        "Update an RC822 message object with a representation of this."
        msg[hdr] = self.name + " <" + self.email + ">"
        msg[hdr + "-Date"] = self.rfc822date()
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = os.path.abspath(subdir)
        self.path = None      # First in-repo path associated with this blob
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def email_out(self, eventnum):
        "Enable do_email_out() to report these."
        msg = RepoSurgeonEmail()
        msg["Event-Number"] = str(eventnum+1)
        msg["Tag-Name"] = self.name
        self.tagger.email_out(msg, "Tagger")
        msg.set_payload(self.comment)
        return str(msg)
    def email_in(self, msg):
        "Update this Tag from a parsed email message."
        modified = False
        newcomment = msg.get_payload().strip() + "\n"
        if newcomment != self.comment:
            modified = True
        self.comment = newcomment
        return modified
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Reset:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name
        self.fileops = []            # blob and file operation list
    def lister(self, eventnum):
        "Enable do_list() to report these."
        topline = self.comment.split("\n")[0]
        return "%6d %s %-50s" % \
                      (eventnum+1, self.committer.isodate()[:-5], topline[:50]) 
    def email_out(self, eventnum):
        "Enable do_email_out() to report these."
        msg = RepoSurgeonEmail()
        msg["Event-Number"] = str(eventnum+1)
        self.author.email_out(msg, "Author")
        self.committer.email_out(msg, "Committer")
        msg.set_payload(self.comment)
        return str(msg)
    def email_in(self, msg):
        "Update this commit from a parsed email message."
        modified = False
        newcomment = msg.get_payload().strip() + "\n"
        if newcomment != self.comment:
            modified = True
        self.comment = newcomment
        return modified
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class Passthrough:
    "Represents a passthrough line."
    def __init__(self, line):
        self.text = text
    def __str__(self):
        return self.text

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                            for obj in self.commands:
                                if isinstance(obj, Blob) and obj.mark == ref:
                                    obj.path = path
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                reset = Reset()
                reset.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    reset.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(reset)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def complain(msg):
    print >>sys.stderr, "reposurgeon:", msg

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: from stdin"))
    elif not os.path.exists(source):
        complain("%s does not exist" % source)
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: from %s" % os.path.relpath(source)))
    else:
        if verbose > 1:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout, viewer)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            complain("couldn't find a repo under %s" % os.path.relpath(source))
            return None
        elif hitcount > 1:
            complain("too many repos under %s" % os.path.relpath(source))
            return None
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            # A FIFO version wouldn't block our reads until
            # the entire file is written - faster, and makes our baton
            # spinner useful -- if it worked.
            #tfname = os.path.join("/tmp/reposurgeon"+`os.getpid()`)
            #os.mkfifo(tfname)
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: from %s repo at '%s'" % (foundname, os.path.relpath(source))));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def filelist(exclude):
    "Return a list of relative paths under the current directory."
    found = []
    for root, dirs, files in os.walk("."):
        for name in files:
            found.append(os.path.join(root, name)) 
        if exclude in dirs:
            dirs.remove(exclude)
    return found

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        complain("no default destination for rebuild")
        return
    if not preferred:
        complain("please prefer a repo type first")
        return

    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + str(os.getpid())
    assert(os.path.isabs(target) and os.path.isabs(staging))
    try:
        os.mkdir(staging)
    except OSError:
        complain("staging directory creation failed")
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout,viewer) = vcstypes[preferred]
    here = os.getcwd()
    try:
        repodir = vcstypes[preferred][0]
        herefiles = set(filelist(exclude=repodir))
        
        os.chdir(staging)
        if os.system(initializer):
            complain("repo initialization failed")
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            complain("repo import failed")
            return
        if os.system(checkout):
            complain("repo checkout failed")
            return
        trackedfiles = set(filelist(exclude=repodir))
        untracked = herefiles - trackedfiles
        if verbose:
            print "reposurgeon: rebuild is complete."

        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + (".~%d~" % backupcount)
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))

        # This is a critical region.  Ignore all signals until we're done.
        # Alas that we lack sigblock support
        if verbose:
            complain("build critical region begins...")
        handlers = []
        for sig in range(1, signal.NSIG):
            if not sig == signal.SIGKILL:
                complain("blocking signal %d" % sig)
                handlers.append(signal.signal(sig, signal.SIG_IGN))

        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            complain("repo backed up to %s" % os.path.relpath(savedir))
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
        # Restore untracked files from the backup directory.
        # We move them to target and then copy back in order
        # to preserve file mod dates and metadata even if
        # shutil.copy2() can't hack that.
        if verbose:
            complain("restoring %s" % " ".join(untracked))
        for keeper in untracked:
            os.rename(os.path.join(savedir, keeper),
                      os.path.join(target, keeper))
            shutil.copy2(os.path.join(target, keeper),
                        os.path.join(savedir, keeper))
        # Revert signals
        for sig in range(1, signal.NSIG):
            if not sig == signal.SIGKILL:
                signal.signal(sig, handlers[sig-1])

        map(lambda (i, s): signal.signal(s, i+1), enumerate(handlers))
        if verbose:
            complain("build critical region ends. Success.")
    finally:
        os.chdir(here)
        #os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        complain("'%s' failed" % cmd)
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.echo = 0
        self.prompt = "reposurgeon% "
        self.repo = None
        self.preferred = None
        self.selection = []
    #
    # Housekeeping hooks.
    #
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def precmd(self, line):
        "Pre-command hook."
        if self.echo:
            print line
        return line
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True
    #
    # The selection-language parsing code starts here.
    #
    def set_selection_set(self, line, default=None):
        "Implement object-selection syntax."
        self.selection = []
        if not self.repo:
            return line
        self.line = line
        try:
            self.selection = list(self.eval_expression())
            if self.line == line:
                self.selection = default
            else:
                self.selection.sort()
        except RepoSurgeonException, e:
            print >>sys.stderr, "reposurgeon:", e.msg
            self.selection = []
        return self.line
    def peek(self):
        return self.line and self.line[0]
    def pop(self):
        if not self.line:
            return ''
        else:
            c = self.line[0]
            self.line = self.line[1:]
            return c
    def push(c):
        self.line = c + self.line[0]
    def eval_expression(self):
        if self.verbose >= 2:
            print "eval_expression(%s)" % self.line
        self.line = self.line.lstrip()
        value = self.eval_disjunct()
        c = self.peek()
        if c and not c.isspace() and not c.isalpha():
            raise RepoSurgeonException("trailing junk on selection: %s" % `self.line`)
        if self.verbose >= 2:
            print "%s <- eval_expression(), left = %s" % (value, `self.line`)
        return value
    def eval_disjunct(self):
        "Evaluate a disjunctive expression (| has lowest precedence)" 
        if self.verbose >= 2:
            print "eval_disjunct(%s)" % self.line
        self.line = self.line.lstrip()
        disjunct = set([])
        while True:
            conjunct = self.eval_conjunct()
            if conjunct is None:
                break
            else:
                disjunct |= conjunct
            self.line = self.line.lstrip()
            if self.peek() == '|':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_disjunct(), left = %s" % (disjunct, `self.line`)
        return disjunct
    def eval_conjunct(self):
        "Evaluate a conjunctive expression (& has higher precedence)" 
        if self.verbose >= 2:
            print "eval_conjunct(%s)" % self.line
        self.line = self.line.lstrip()
        conjunct = set(range(0, len(self.repo.commands)))
        while True:
            term = self.eval_term()
            if term is None:
                break
            else:
                conjunct = conjunct & term
            self.line = self.line.lstrip()
            if self.peek() == '&':
                self.pop()
            else:
                break
        if self.verbose >= 2:
            print "%s <- eval_conjunct(), left = %s" % (conjunct, `self.line`)
        return conjunct
    def eval_term(self):
        if self.verbose >= 2:
            print "eval_term(%s)" % self.line
        self.line = self.line.lstrip()
        term = self.eval_visibility()
        if term is None:
            term = self.eval_polyrange()
            if term is None:
                term = self.eval_textsearch()
        if self.verbose >= 2:
            print "%s <- eval_term(), left = %s" % (term, `self.line`)
        return term
    def eval_visibility(self):
        "Parse a visibility spec."
        if self.verbose >= 2:
            print "eval_visibility(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() == "=":
            visibility = None
        else:
            typeletters = {
                "B" : Blob,
                "C" : Commit,
                "T" : Tag,
                "R" : Reset,
                "P" : Passthrough,
                }
            visible = set([])
            modmode = None
            self.pop()
            while self.peek() in tuple(typeletters.keys()):
                c = self.pop()
                if c in typeletters:
                    visible.add(typeletters[c])
            # We need a special check here because these expressions
            # could otherwise run onto the text part of the command.
            if self.peek() not in "()|& ":
                raise RepoSurgeonException("garbled type mask at %s" % `self.line`)
            if self.verbose >= 2:
                print "reposurgeon: visibility set is %s with %s left" % (map(lambda x: x.__name__, visible), `self.line`)
            selected = []
            for i in set(range(0, len(self.repo.commands))):
                cmd = self.repo.commands[i]
                if cmd.__class__ in visible:
                    selected.append(i)
            visibility = set(selected)
        if self.verbose >= 2:
            print "%s <- eval_visibility(), left = %s" % (visibility, `self.line`)
        return visibility
    def eval_polyrange(self):
        "Parse a polyrange specification (list of intervals)."
        if self.verbose >= 2:
            print "eval_polyrange(%s)" % self.line
        self.line = self.line.lstrip()
        polyrange_initials = (":","0","1","2","3","4","5","6","7","8","9","$")
        if not self.peek() in polyrange_initials:
            polyrange = None
        else:
            selection = []
            while self.peek() in polyrange_initials + (".", ","):
                # First, literal command numbers (1-origin)
                match = re.match("[0-9]+", self.line)
                if match:
                    number = match.group()
                    selection.append(int(number)-1)
                    self.line = self.line[len(number):]
                    continue
                # Next, mark references
                match = re.match(":[0-9]+", self.line)
                if match:
                    markref = match.group()
                    self.line = self.line[len(markref):]
                    for (i, cmd) in enumerate(self.repo.commands):
                        if hasattr(cmd, "mark") and cmd.mark == markref:
                            selection.append(i)
                            break
                        elif hasattr(cmd, "committish") and cmd.committish == markref:
                            selection.append(i)
                            break
                    else:
                        raise RepoSurgeonException("mark %s not found." % markref)
                    continue
                # $ means last commit, a la ed(1).
                if self.peek() == "$":
                    selection.append(len(self.repo.commands)-1)
                    self.pop()
                    continue
                # Comma just delimits a location spec
                if self.peek() == ",":
                    self.pop()
                    continue
                # Following ".." means a span
                if self.line[:2] == "..":
                    if selection:
                        selection.append("..")
                        self.line = self.line[2:]
                        continue
                    else:
                        raise RepoSurgeonException("start of span is missing")
                        return line
            if self.verbose >= 2:
                print "reposurgeon: location list is %s with %s left" % (selection, `self.line`)
            # Resolve spans
            resolved = []
            spanning = last = 0
            for elt in selection:
                if elt == '..':
                    spanning = True
                else:
                    if spanning:
                        resolved += range(last+1, elt+1)
                        spanning = False
                    else:
                        resolved.append(elt)
                    last = elt
            selection = resolved
            if self.verbose >= 2:
                print "reposurgeon: resolved list is %s with %s left" % (selection, `self.line`)
            # Sanity checks
            if spanning:
                raise RepoSurgeonException("incomplete range expression.")
            for elt in selection:
                if elt < 0 or elt > len(self.repo.commands)-1:
                    print RepoSurgeonException("event number %s out of range" % elt)
            polyrange = set(selection)
        if self.verbose >= 2:
            print "%s <- eval_polyrange(), left = %s" % (polyrange, `self.line`)
        return polyrange
    def eval_textsearch(self):
        "Parse a text search specification."
        if self.verbose >= 2:
            print "eval_textsearch(%s)" % self.line
        self.line = self.line.lstrip()
        if not self.peek() == '/':
            textsearch = None
        elif '/' not in self.line[1:]:
            raise RepoSurgeonException("malformed text search specifier")
        else:
            assert(self.pop() == '/')
            endat = self.line.index('/')
            regex = re.compile(self.line[:endat])
            self.line = self.line[endat+1:]
            matchers = []
            for (i, cmd) in enumerate(self.repo.commands):
                # This catches commits and tags
                if hasattr(cmd, "comment") and regex.search(cmd.comment):
                    matchers.append(i)
                # And this catches passthroughs
                elif hasattr(cmd, "text") and regex.search(cmd.text):
                    matchers.append(i)
                # We don't do blobs because it would be too slow
                # and not very useful.
            if self.verbose >= 2:
                print "%s <- eval_textsearch(), left = %s" % (matchers, `self.line`)
            return set(matchers)

    def report_select(self, line, method):
        "Generate a repository report on all objects with a specified method."
        if not self.repo:
            complain("no repo is loaded.")
            return
        default = map(lambda x: x[0], filter(lambda (n, o): hasattr(o, method), enumerate(self.repo.commands)))
        self.set_selection_set(line, default)
        outfile = line.strip()
        if outfile and outfile != '-':
            fp = open(outfile, "w")
        else:
            fp = sys.stdout
        for i in self.selection:
            command = self.repo.commands[i]
            if hasattr(command, method):
                fp.write(getattr(command, method)(i) + "\n")
        if outfile:
            fp.close()
    #
    # On-line help and instrumentation
    #
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: verbose %d" % self.verbose
    def help_verbose(self):
        print """
'verbose 1' enables progress messages, 'verbose 0' disables them. Higher levels
of verbosity are available but intended for developers only.
"""
    def do_echo(self, line):
        "Set or clear echoing commands before processing (for regression tests)"
        try:
            self.echo = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
        if self.verbose:
            print "reposurgeon: echo %d" % self.echo
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    #
    # Serialization and de-serialization.
    #
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                complain("known types are %s.") % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdout)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.preferred, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def help_rebuild(self):
        print """
View a repo through the default GUI browser for its version control system.
Note that this does not show the in-core state; it is mainly useful for
doing a quick eyeball check ofter a rebuild command.
"""
    #
    # Information-gathering
    #
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            def count(otype):
                return len(filter(lambda x: isinstance(x,otype),self.repo.commands))
            print "%d commands, %d blobs, %d commits, %d tags, %d resets, %d marks." % \
                  (len(self.repo.commands),
                   count(Blob), count(Commit), count(Tag), count(Reset),
                   self.repo.nmarks)
            if self.repo.type:
                for (legend, command) in zip(("Subdirectory:", "Exporter:", "Initializer:", "Importer:", "Checkout:", "Viewer:"), vcstypes[self.repo.type]):
                    print "%14s %s" % (legend, command)
        else:
            print "reposurgeon: no repository loaded."
    def help_stats(self):
        print """
Report size statistics and import/export method information after reading
a repo or stream.
"""
    def do_view(self, line):
        "View a repo through its GUI."
        if not self.preferred:
            complain("prefer a repo type first.")
            return
        gui = vcstypes[self.preferred][5]
        if not gui:
            complain("no GUI is available.")
            return
        os.system(gui)
    def do_index(self, line):
        "Generate a summary listing of objects."
        if not self.repo:
            complain("no repo is loaded.")
            return
        # We could do all this logic using report_select() and index() methods
        # in the objects, but that would have two disavadntages.  First, we'd
        # get a default-set computation we don't want.  Second, for this
        # function it's helpful to have the method strings close together so
        # we can maintain columnation.
        default = map(lambda x: x[0], filter(lambda (n, o): not isinstance(o, Blob), enumerate(self.repo.commands)))
        self.set_selection_set(line, default)
        for i in self.selection:
            command = self.repo.commands[i]
            if isinstance(command, Blob):
                print "%6d blob   %6s    %s" % (i+1, command.mark,command.path)
                continue
            if isinstance(command, Commit):
                print "%6d commit %6s    %s" % (i+1, command.mark or '-', command.branch) 
                continue
            if isinstance(command, Tag):
                print "%6d tag      -       %4s" % (i+1, command.name,) 
                continue
            if isinstance(command, Reset):
                print "%6d branch %6s    %s" % (i+1, command.committish or '-', command.ref) 
                continue
            else:
                print "?      -      %s" % (command,) 
    def help_index(self):
        print """
Display four columns of info on selected objects: their number, their
type, the associate mark (or '-' if no mark) and a summary field
varying by type.  For a branch or tag it's the reference; for a commit
it's the commit branch; for a blob it's the repository path of the
file in the blob.
"""
    def do_list(self, line):
        "Generate a human-friendly listing of objects."
        self.report_select(line, "lister")

    def help_list(self):
        print """
Display commits in a human-friendly format; the first column is raw
event numbers, the second a timestamp, and the third the leading text
of the comment.  If there is a second argument, or the first is not
recognized as a selection set, it will be taken as the name of the
file to report to; no argument, or one of '-'; writes to standard
output.
"""
    def do_resolve(self, line):
        "Display the set of event numbers generated by a section set."
        self.set_selection_set(line)
        print map(lambda x: x+1, self.selection)
    def help_index(self):
        print """
Does nothing but resolve a selection-set expression
and echo the resulting event-number set to standard
output. Implemented mainly for recression testing, but may be useful
for exploring the selection-set language.
"""
    #
    # Editing commands
    #
    def do_mailbox_out(self, line):
        "Generate a mailbox file representing object metadata."
        self.report_select(line, "email_out")
    def help_mailbox_out(self):
        print """
Emit a mailbox file of messages in RFC822 format representing the
contents of the metadata in selected commits and annotated tags. Takes
a selection set; members of the set other than commits and annotated
tags are ignored.  If there is a second argument, or the first is not
recognized as a selection set, it will be taken as the name of the
file to report to; no argument, or one of '-'; writes to standard
output.
"""
    def do_mailbox_in(self, line):
        "Accept a mailbox file representing object metadata and update from it."
        infile = line.strip()
        if infile and infile != '-':
            fp = open(infile)
        else:
            fp = sys.stdin
        update_list = []
        while True:
            msg = RepoSurgeonEmail.readmsg(fp)
            if not msg:
                break
            update_list.append(email.message_from_string(msg))
        if infile:
            fp.close()
        # First, a validation pass
        for (i, message) in enumerate(update_list):
            if "Event-Number" not in message:
                raise RepoSurgeonError("missing event number in update %d" % i)
            eventnum = int(message["Event-Number"]) - 1
            if eventnum < 0 or eventnum >= len(self.repo.commands):
                raise RepoSurgeonException("event number %d out of range in update %d" % (eventnum, i+1))
            event = self.repo.commands[eventnum]
            if not hasattr(event, "email_in"):
                raise RepoSurgeonException("event %d cannot be modified" % (eventnum+1,))
        # Now apply the updates
        modified = []
        for update in update_list:
            eventnum = int(update["Event-Number"]) - 1
            event = self.repo.commands[eventnum]
            if event.email_in(update):
                modified.append(eventnum+1)
        if self.verbose:
            if not modified:
                print "reposurgeon: no events modified."
            else:
                print "reposurgeon: modified events are %s." % (modified,)

    def help_mailbox_in(self):
        print """
Accept a mailbox file of messages in RFC822 format representing the
contents of the metadata in selected commits and annotated tags. Takes
no selection set.  If there is an argument it will be taken as the
name of a mailbox file to read from; no argument, or one of '-'; reads
from standard output.

Users should be aware that modifying an Event-Number field will change
which event the update from that message is applied to.  This is
unlikely to have good results.

Event updates are atomic; if reposurgeon throws an error while in this
command events updated before the error will keep their changed state,
but no event will be partially modified. Event numbers are validated
before any individual event is updated.

At present only the comment fields of commits and tags are updated from
the mailbox contents; commit and tag metadata cannot be altered. This
may change in a future release.
"""

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        interpreter.use_rawinput = False
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.use_rawinput = True
                    interpreter.verbose = 1
                    interpreter.cmdloop()
                    interpreter.use_rawinput = False
                else:
                    interpreter.onecmd(interpreter.precmd(cmd))
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end
