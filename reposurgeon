#!/usr/bin/env python
#
# rs - a repository surgeon.
#
import sys, os, getopt, commands, cStringIO, cmd, tempfile, readline, time

#
# All knowledge about specific version-control systems lives in the
# following dictionary. The key is the subdirectory name that tells us
# we have a given VCS active.  The values in the tuple are,
# respectively:
#
# * Name of the SCM for diagnostic messages
# * Command to export from the SCM to the interchange format
# * Command to initialize a new repo
# * Command to import from the interchange format
# * Command to check out working copies of the repo files.
#
# Note that some of the commands used here are plugins or extenstions
# that are not part of the basic VCS. Thus these may fail when called;
# we need to be prepared to cope with that.
#
# Subversion/RCS/CVS aren't in this table because exporting from them
# requires fixups of usernames in the committer information to full
# email addresses.  Trying to handle that entirely inside this tool
# would be excessively messy, so we don't. Instead we let the user
# transform dump files and cope with the export/import himself.
#
version="1.0"

vcstypes = {
    "git" : (".git",
      "git fast-export -M -C --all >%s",
      "git init",
      "git fast-import <%s",
      "git checkout"),
     # FIXME: hg and bzr methods are untested
    "hg" : (".hg",
      "hg-fast-export.sh %s",   # Not part of stock hg
      "hg init",
      "hg fast-import %s",      # Not part of stock hg
      "hg checkout"),
    "bzr" : (".bzr",
      "bzr-fast-export --plain %s",
      "bzr init",
      "bzr fast-import %s",
      "bzr checkout"),
    }

class Baton:
    "Ship progress indications to stderr."
    def __init__(self, prompt, endmsg='done'):
        self.stream = sys.stderr
        self.stream.write(prompt + "...")
        if os.isatty(self.stream.fileno()):
            self.stream.write(" \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if os.isatty(self.stream.fileno()):
            if ch:
                self.stream.write(ch)
            else:
                self.stream.write("-/|\\"[self.count % 4])
                self.stream.write("\010")
            self.stream.flush()
        self.count = self.count + 1
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class Action:
    "Represents an instance of a person acting on the repo."
    def __init__(self, person):
        person = person.replace(" <", "|").replace("> ", "|")
        (self.name, self.email, self.when) = person.strip().split("|")
    def __str__(self):
        return self.name + " <" + self.email + "> " + self.when

class Blob:
    "Represent a detached blob of data referenced by a mark."
    def __init__(self, subdir):
        self.mark = None
        self.subdir = subdir
    def blobfile(self):
        return self.subdir + "/blob-" + self.mark
    def __str__(self):
        dp = open(self.blobfile())
        content = dp.read()
        dp.close()
        return "blob\nmark %s\ndata %d\n%s\n" % (self.mark, len(content), content)

class Tag:
    "Represents an annotated tag."
    def __init__(self, name, committish, tagger, content):
        self.name = name
        self.committish = committish
        self.tagger = tagger
        self.comment = content
    def __str__(self):
        return "tag %s\nfrom %s\ntagger %s\ndata %d\n%s\n" \
             % (self.name, self.committish, self.tagger, len(self.comment), self.comment)

class Branch:
    "Represents a branch creation."
    def __init__(self):
        self.ref = None
        self.committish = None
    def __str__(self):
        st = "reset %s\n" % self.ref
        if self.committish:
            st += "from %s\n\n" % self.committish
        return st

class Commit:
    "Generic commit object."
    def __init__(self):
        self.mark = None             # Mark name of commit (may be None)
        self.author = None           # Author of commit
        self.committer = None        # Person responsible for committing it.
        self.comment = None          # Commit comment
        self.parents = []            # List of parent nodes
        self.branch = None           # branch name (deduced optimization hack)
        self.fileops = []            # blob and file operation list
    def __str__(self):
        st = "commit %s\n" % self.branch
        if self.mark:
            st += "mark %s\n" % self.mark
        if self.author:
            st += "author %s\n" % self.author
        if self.committer:
            st += "committer %s\n" % self.committer
        st += "data %d\n%s" % (len(self.comment), self.comment) 
        if self.parents:
            st += "from %s\n" % self.parents[0]
        for ancestor in self.parents[1:]:
            st += "merge %s\n" % self.parents[0]
        for op in self.fileops:
            if type(op) == type(""):
                st += op + "\n"
            else:
                st += " ".join(op[:4]) + "\n"
                if op[2] == 'inline':
                    fp = open(op[4])
                    content = fp.read()
                    fp.close()
                    st += "data %d\n%s\n" % (len(content), content)
        return st + "\n"

class RepoSurgeonException:
    def __init__(self, msg):
        self.msg = msg

class Repository:
    "Generic repository object."
    def __init__(self):
        self.type = None
        self.sourcedir = None
        self.commands = []    # A list of the commands encountered, in order
        self.nmarks = 0
        self.refs_to_branches = {}
        self.import_line = 0
        self.subdir = ".rs"
    def error(self, msg, atline=True):
        if atline:
            raise RepoSurgeonException(msg + (" at line " + `self.import_line`))
        else:
            raise RepoSurgeonException(msg)
    def __del__(self):
        os.system("rm -fr %s" % (self.subdir,))
    def fast_import(self, fp, baton=None):
        "Initialize repo object from fast-import stream."
        try:
            os.system("rm -fr %s; mkdir %s" % (self.subdir, self.subdir))
        except OSError:
            self.error("can't create operating directory", atline=False)
        self.import_line = 0
        linebuffers = []
        ncommits = 0
        def read_data(dp, line=None):
            if not line:
                line = readline()
            if line.startswith("data <<"):
                delim = line[7:]
                while True:
                    dataline = fp.readline()
                    if dataline == delim:
                        break
                    elif not dataline:
                        raise RepoSurgeonException("EOF while reading blob")
            elif line.startswith("data"):
                try:
                    count = int(line[5:])
                    dp.write(fp.read(count))
                except ValueSelf.Error:
                    raise self.error("bad count in data")
            else:
                raise self.error("malformed data header %s" % `line`)
            return dp
        def readline():
            if linebuffers:
                line = linebuffers.pop()
            else:
                self.import_line += 1
                line = fp.readline()
            return line
        def pushback(line):
            linebuffers.append(line)
        while True:
            line = readline()
            if not line:
                break
            elif not line.strip():
                continue
            elif line.startswith("blob"):
                blob = Blob(self.subdir)
                line = readline()
                if line.startswith("mark"):
                    blob.mark = line[5:].strip()
                    read_data(open(blob.blobfile(), "w")).close()
                    self.nmarks += 1
                else:
                    self.error("missing mark after blob")
                self.commands.append(blob)
                if baton:
                    baton.twirl()
            elif line.startswith("data"):
                self.error("unexpected data object")
            elif line.startswith("commit"):
                commitbegin = self.import_line
                commit = Commit()
                commit.branch = line.split()[1]
                ncommits += 1
                inlinecount = 0
                while True:
                    line = readline()
                    if not line:
                        self.error("EOF after commit")
                    elif line.startswith("mark"):
                        commit.mark = line[5:].strip()
                        self.nmarks += 1
                    elif line.startswith("author"):
                        try:
                            commit.author = Action(line[7:])
                        except ValueError:
                            self.error("malformed author line")
                    elif line.startswith("committer"):
                        try:
                            commit.committer = Action(line[10:])
                        except ValueError:
                            self.error("malformed committer line")
                    elif line.startswith("data"):
                        dp = read_data(cStringIO.StringIO(), line)
                        commit.comment = dp.getvalue()
                        dp.close()
                    elif line.startswith("from") or line.startswith("merge"):
                        commit.parents.append(line.split()[1])
                    elif line[0] in ("C", "D", "R"):
                        commit.fileops.append(line.strip().split())
                    elif line == "filedeletall\n":
                        commit.fileops.append("filedeleteall")
                    elif line[0] == "M":
                        (op, mode, ref, path) = line.split()
                        if ref[0] == ':':
                            copyname = self.subdir + "/blob-" + ref
                            commit.fileops.append((op, mode, ref, path, copyname))
                        elif ref[0] == 'inline':
                            copyname = self.subdir + "/inline-" + `inline_count`
                            self.read_data(open(copyname, "w")).close()
                            inline_count += 1
                            commit.fileops.append((op, mode, ref, path, copyname))
                        else:
                            self.error("unknown content type in filemodify")
                    else:
                        pushback(line)
                        break
                if not (commit.mark and commit.author and commit.committer):
                    self.import_line = commitbegin
                    self.error("missing required fields in commit")
                self.commands.append(commit)
                if baton:
                    baton.twirl()
            elif line.startswith("reset"):
                branch = Branch()
                branch.ref = line[6:].strip()
                line = readline()
                if line.startswith("from"):
                    branch.committish = line[5:].strip()
                else:
                    pushback(line)
                self.commands.append(branch)
                if baton:
                    baton.twirl()
            elif line.startswith("tag"):
                tagname = line[4:].strip()
                line = readline()
                if line.startswith("from"):
                    referent = line[5:].strip()
                else:
                    self.error("missing from after tag")
                line = readline()
                if line.startswith("tagger"):
                        try:
                            tagger = Action(line[7:])
                        except ValueError:
                            self.error("malformed tagger line")
                else:
                    self.error("missing tagger after from in tag")
                dp = read_data(cStringIO.StringIO())
                self.commands.append(Tag(tagname,
                                       referent, tagger, dp.getvalue()))
                if baton:
                    baton.twirl()
            else:
                # Simply pass through any line we don't understand.
                commands.append(line)
        if baton:
            baton.end()
    def fast_export(self, fp, baton=None):
        "Dump the repo object in fast-export format."
        for command in self.commands:
            if baton:
                baton.twirl()
            fp.write(str(command))
        if baton:
            baton.end()

def read_repo(source, preferred, verbose):
    "Read a repository using fast-import."
    if source == '-':
        repo = Repository()
        repo.fast_import(sys.stdin, verbose and Baton("reposurgeon: importing from stdin"))
    elif not os.path.exists(source):
        print >>sys.stderr, "reposurgeon: %s does not exist" % source
        return None
    elif not os.path.isdir(source):
        repo = Repository()
        repo.fast_import(open(source), verbose and Baton("reposurgeon: importing from %s" % source))
    else:
        if verbose:
            if preferred:
                print "reposurgeon: looking for a %s repo..." % preferred
            else:
                print "reposurgeon: looking for any repo..."
        hitcount = 0
        for (name, (dirname, exporter, initializer, importer, checkout)) in vcstypes.items():
            if preferred and name != preferred:
                continue
            subdir = os.path.join(source, dirname)
            if os.path.exists(subdir) and os.path.isdir(subdir):
                (foundname, foundexporter) = (name, exporter)
                hitcount += 1
        if hitcount == 0:
            print >>sys.stderr,"reposurgeon: couldn't find a repo under %s" % source
            return None
        elif hitcount > 1:
            print >>sys.stderr,"reposurgeon: too many repos under %s" % source
            return None
        elif verbose:
            print "reposurgeon: recognized %s repository under %s" % (foundname, source)
        try:
            repo = Repository()
            repo.type = foundname
            repo.sourcedir = source
            (tfdesc, tfname) = tempfile.mkstemp()
            cmd = ""
            if source != '.':
                cmd += "cd %s >/dev/null;" % source
            cmd += foundexporter % tfname
            act(cmd)
            tp = open(tfname)
            repo.fast_import(tp, verbose and Baton("reposurgeon: importing from repo"));
            tp.close()
        finally:
            os.remove(tfname)
    return repo

def rebuild_repo(repo, target, preferred, verbose):
    "Rebuild a repository from the captured state."
    if not target and repo.sourcedir:
        target = repo.sourcedir
    if target:
        target = os.path.abspath(target)
    else:
        print >>sys.stderr, "reposurgeon: no default destination for rebuild."
        return
    if not preferred:
        print >>sys.stderr, "reposurgeon: please prefer a repo type first."
        return
    # Create a new empty directory to do the rebuild in
    staging = target + "-stage" + os.getpid()
    assert(isabspath(target) and isabspath(staging))
    try:
        os.mkdir(staging)
    except OSError:
        print >>sys.stderr, "reposurgeon: staging directory creation failed."
        return
    # Try the rebuild in the empty staging directory 
    (dirname,exporter,initializer,importer,checkout) = vcstypes[self.preferred]
    here = os.getcwd()
    try:
        os.chdir(staging)
        if os.system(initializer):
            print >>sys.stderr, "reposurgeon: repo initialization failed."
            return
        (tfdesc, tfname) = tempfile.mkstemp()
        tp = open(tfname, "w")
        repo.fast_export(tp, verbose and Baton("reposurgeon: exporting"))
        tp.close()
        if os.system(importer % tfname):
            print >>sys.stderr, "reposurgeon: repo import failed."
            return
        if os.system(checkout):
            print >>sys.stderr, "reposurgeon: repo checkout failed"
            return
        os.chdir(here)
        # Rebuild succeeded - make an empty backup directory
        backupcount = 1
        while True:
            savedir = target + ".~%d%~" % backupcount
            if os.path.exists(savedir):
                backupcount += 1
            else:
                break
        os.mkdir(savedir)
        assert(os.path.abspath(savedir))
        # Move the unmodified repo contents in target to the backup directory.
        # Then move the staging contents to the target directory.
        for sub in os.listdir(target):
            os.rename(os.path.join(target, sub),
                      os.path.join(savedir, sub))
        if verbose:
            print >>sys.stderr, "reposurgeon: repo backed up to %s" % savedir
        for sub in os.listdir(staging):
            os.rename(os.path.join(staging, sub),
                      os.path.join(target, sub))
    finally:
        os.chdir(here)
        os.remove(tfname)
        os.system("rm -fr " + staging)

def act(cmd):
    (err, out) = commands.getstatusoutput(cmd)
    if err:
        print >>sys.stderr,"'%s' failed" % cmd
        return False
    else:
        return True

def fatal(msg):
    print >>sys.stderr, "reposurgeon:", msg
    raise SystemExit, 1

class RepoSurgeon(cmd.Cmd):
    "Repository surgeon command interpreter."
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.use_rawinput = True
        self.verbose = 0
        self.prompt = "reposurgon% "
        self.repo = None
        self.preferred = None
    def postcmd(self, stop, line):
        if line == "EOF":
            return True
    def emptyline(self):
        pass
    def help_help(self):
        print "Show help for a command. Follow with a space and the command name"
    def do_verbose(self, line):
        "'verbose 1' enables progress and statistics messages, 'verbose 0' disables them."
        try:
            self.verbose = int(line)
        except ValueError:
            print "reposurgeon: verbosity value must be an integer"
    def do_version(self, line):
        "Report the program version and supported version-control systems."
        print "reposurgeon " + version + " supporting " + " ".join(map(lambda x: x[0], vcstypes.keys()))
    def do_prefer(self, line):
        "Report or select the preferred repository type."
        if line:
            known = " ".join(vcstypes.keys())
            if line.lower() in map(lambda x: x.lower(), vcstypes.keys()):
                self.preferred = line
            else:
                print >>sys.stderr,"reposurgeon: known types are %s." % known
        if self.verbose:
            if not self.preferred:
                print "reposurgeon: no preferred type has been set."
            else:
                print "reposurgeon: %s is the preferred type." % self.preferred
    def help_prefer(self):
        print """
Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.

If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.
"""
    def do_read(self, line):
        "Read in a repository for surgery."
        self.preferred = None 
        if not line or line == '.':
            line = os.getcwd();
        if self.repo and self.verbose:
            print "reposurgeon: previous data discarded."
        self.repo = read_repo(line, self.preferred, self.verbose)
        if self.repo and self.repo.type:
            self.preferred = self.repo.type
    def help_read(self):
        print """
A read command with no arguments is treated as 'read .', operating on the
current directory.
        
With a directory-name argument, this command attempts to read in the
contents of a repository in any supported version-control system under
that directory.

If the argument is the name of a plain file, it will be read in as a
fast-import stream.

With an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).
"""
    def do_stats(self, line):
        "Report on the loaded repository infrmation"
        if self.repo:
            print "reposurgeon: %d commands, %d blobs, %d commits, %d marks, %d tags" % \
                  (len(self.repo.commands),
                   len(filter(lambda x: isinstance(x,Blob),self.repo.commands)),
                   len(filter(lambda x: isinstance(x,Commit),self.repo.commands)),
                   self.repo.nmarks,
                   len(filter(lambda x: isinstance(x,Tag),self.repo.commands)))
        else:
            print "reposurgeon: no repository loaded."
    def do_write(self, line):
        "Stream out the results of repo surgery."
        if not line:
            line = '-'
        if line == '-':
            self.repo.fast_export(sys.stdin)
        else:
            try:
                out = open(line, "w")
                self.repo.fast_export(out)
                out.close()
            except OSError:
                print "reposurgeon: open of %s for write failed.\n" % line
    def help_write(self):
        print """
Dump a fast-import stream representing the repostory to standard output
(if argument is empty or '-') or a file.  Fails if the argument exists
and is a directory or anything other than a plain file.
"""
    def do_rebuild(self, line):
        "Rebuild a repository from the edited state."
        rebuild_repo(self.repo, line, self.prepared, self.verbose)
    def help_rebuild(self):
        print """
Rebuild a repository from the state held by reposurgeon.  The argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import stream), it
defaults to that directory.  If the target directory is nonempty
its contents are backed up to a save directory.
"""
    def do_shell(self, line):
        "Execute a shell command."
        os.system(line)
    def do_EOF(self, line):
        "Terminate reposurgeon."
        return True

if __name__ == '__main__':
    try:
        interpreter = RepoSurgeon()
        if not sys.argv[1:]:
            sys.argv.append("-")
        for arg in sys.argv[1:]:
            for cmd in arg.split(";"):
                if cmd == '-':
                    interpreter.onecmd("verbose 1")
                    interpreter.cmdloop()
                else:
                    interpreter.onecmd(cmd)
    except RepoSurgeonException, e:
        fatal(e.msg)
    except KeyboardInterrupt:
        print ""

# end
