<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rev="made" href="mailto:esr@snark.thyrsus.com" />
<link rel="stylesheet" href="/~esr/sitestyle.css" type="text/css" media='all'/>
<link rel="stylesheet" href="/~esr/sitestyle-print.css" type="text/css" media='print'/>
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="MSSmartTagsPreventParsing" content="TRUE" />
<a href='http://www.anti-leech.com/spam/spambot_stopper.php'></a>
<title>DVCS migration: supporting git and hg access from one repo</title>
</head>
<body>

<div id="Header">
<table width="100%" cellpadding="0" summary="Canned page header">
<tr>
<td>
<script language="JavaScript">
<!-- 
document.writeln(document.title);
 // -->
</script>
</td>
<td align="right">
<script language="JavaScript" src="/~esr/datestamp.js" type='text/javascript'></script>
</td>
</tr>
</table>
</div>

<div id="Menu">
	<hr/>
	<a href="/~esr" title="My home page">Home Page</a><br />
	<a href="/~esr/whatsnew.html" title="What's new on this site">What's New</a><br />
	<a href="/~esr/sitemap.html" title="Map of the site">Site Map</a><br />
	<a href="/~esr/software.html" title="Software I maintain">Software</a><br />
	<a href="/~esr/projects.html" title="My projects">Projects</a><br />
	<a href="/~esr/faqs/" title="My FAQ documents">HOWTOs</a><br />
	<a href="/~esr/writings/" title="Essays and ruminations">Essays</a><br />
	<a href="/~esr/personal.html" title="Portrait of the author">Personal</a><br />
	<a href="http://www.ibiblio.org/esrblog/">Weblog</a><br/>	
	<a href="/~esr/netfreedom/">Freedom!</a><br />
	<a href="/~esr/guns/">Firearms!</a><br />
	<hr/>
</div>

<div id="Content">

<h1 id="history">Major revisions<h1>

<p>1.0 (2011-10-25) Original version.

<p>2.0 (2011-11-04) Much more about CVS-to-git conversion, including
recommending <code>git cvsimport</code>. I started numbering versions
at this point.</p>

<p>2.1 (2011-11-07) Updated for reposurgeon 1.7.</p>

<p>2.2 (2011-11-10) Updated for reposurgeon 1.8.</p>

<h1 id="overview">Overview</h1>

<p>Distributed version control systems (DVCSes) are powerful and
liberating tools for software developers, but projects aiming to
choose one of the major contenders can find themselves mired in
contention and politics.  The most common such controversy is whether
to use git or hg (aka Mercurial).  With a little planning it's
possible to have it both ways, allowing developers to use either git
or hg to work with the same repository.</p>

<p>This page is a guide to up-converting your repository, finding the
tools you need, and adopting practices that will reduce process and
political friction to a minimum.</p>

<p>The technical fact central to the strategy I'm going to describe is
that as of late 2011 an hg plugin already exists to allow seamless
access to a git repository - but the reverse is not true.  So we'll
explain how to create a git repository and then line up the tools to
access it in several different ways.</p>

<p>But tools aren't the end of the story. Your developers will need
some education in good practice to get the most out of the tools.
I'll cover that aspect as well.</p>

<h1 id="conversion">Step One: Conversion</h1>

<p>Your first step will be converting your repository to git. In 90%
of cases you'll be converting from CVS or Subversion, and those are
the cases we'll cover here.  If you're using something older or
weirder, you're on your own for this step.</p>

<p>Before you can do your conversion, you'll need to put together an
authors file.  Subversion and CVS identify users by a local Unix login
name; DVCSes use pairs of fullnames and email addresses. The authors file
should specify a full name and email address for each local user ID in
your repo. Each line should be in the following form:</p>

<pre>
foonly = Fred Foonly &lt;foonly@foobar.com&gt;
</pre>

<h2 id="cvs_to_git">CVS to git</h2> 

<p>If you are using CVS, you have (at least) two conversion options.
Under most circumstances, the best option is to use the cvsimport
plugin of git itself.  I recommend passing it the following options:</p>

<dl>
<dt>-s '~'</dt>
<dd>Map slashes in CVS tag names to tildes (or something else they
don't contain). This avoids confusing git, which will otherwise try to
create directories beneath .git/refs/tags.</dd>
<dt>-u</dt>
<dt>Map underscores in tag names to periods. This is just cosmetic</dt>
<dt>-k</dt>
<dd>Suppress CVS keyword explansion.  As the manual page says, this
avoids a lot of tiny, noisy changesets.</dd>
<dt>-m</dt>
<dd>Attempt merge recognition by matching committer headers.</dd>
<dt>-A</dt>
<dd>Pass in your authors file.</dd>
<dt>-R</dt>
<dd>Tell it to generate a map of CVS revisions.</dd>
<dt>-z 90</dt>
<dd>Shorten the time interval within which CVS commits can be grouped
into changesets.  This makes the history noisier, but may protect you
if the clock on the system where the CVS repo was hosted was unstable;
in that situation it reduces the odds that <code>git cvsimport</code> 
will be confused by out-of-time-order commits.</dd>
<dt>-v</dt>
<dd>This tool runs for a while on large repositories; its default
silent mode can be disconcerting.</dd>
<dt>-C</dt>
<dd>Unpacking in the current directory is the default behavior, but
probably not what you want.</dd>
</dl>

<p>The reason this is normally your best option is that it converts
straight to git, avoiding issues produced by the other major
conversion tools which either go through Subversion as an intermediate 
stage or have Subversion-based assumptions baked into them. Also, the
-R option is immensely helpful for reference-lifting. But read
the warnings on the manual page; under some (rare) circumstances this
tool can produce incorrect conversions.</p>

<p>Another option is the <a
href="http://cvs2svn.tigris.org/cvs2git.html">cvs2git</a> tool dervied
from cvs2svn.  The hard part - deducing changesets from CVS's per-file
commits - is shared with <code>cvs2svn</code>, which has probably been more
extensively battle-tested than any other CVS converter out there. The
drawbacks are (1) There is no -A option, and (b) your converted
history will contain the same sorts of cruft that cvs2svn generates
(see below).</p>

<p>I have done a test conversion of a CVS repo with ten years of
history with <code>cvs2git</code> and it seemed to work as well as
<code>cvs2svn</code> (but not as well as <code>git cvsimport</code>).
I had to git reset &#45l&#45;hard afterwards to actually materialize
the files in the working directory.</p>

<p>Finally, you can use <a
href="http://cvs2svn.tigris.org/cvs2svn.html">cvs2svn</a> to convert
from CVS to Subversion, then from Subversion to git. I've done this,
and it worked - but see the description of cvs2svn artifacts later on.
Use the -A option of <code>cvs2svn</code> (which works just like -A in
<code>git cvsimport</code>) to pass it your authors file.</p>

<h2 id="svn_to_git">Subversion to git</h2>

<p>For Subversion to git lifting, you have no fewer than three options
with two of them easily confused.  The easiest choice, and the one I
normally use, is git-svn.  This is a plugin for git that supports
working with Subversion servers; "git svn clone" will pull the
contents of a Subversion server (specified by Subversion URL) into a
local git repository.</p>

<p>git-svn has a lot of options, most of them having to do with its
use as a gateway to a live Subversion server.  For doing a one-time
repo conversion, here are the only two you usually need to know
about</p>

<dl>
<dt>-A (or &#45;&#45;authors-file)</dt>
<dd><p>Specify your authors file.</p>

<dt>&#45;&#45;stdlayout</dt>
<dd><p>Inform git-svn that your project has a standard
trunk/tags/branches layout. git-svn will use this to create
corresponding git tags and branches.</p>

<dt>&#45;&#45;no-metadata</dt>
<dd><p>Normally each comment in the conversion will contain a metadata
line pointing back to the Subversion commit it was generated
from. This flag suppresses that.  Because recent versions of
reposurgeon can parse this metadata and then strip it out, you 
probably do not want to use this option.</p>
</dd>

<p>Because git-svn is designed for live gatewaying, what it does with
tags and branches is not quite what you want for a one-time conversion
to a standalone git repo. It imports all branches and tags as remote
svn branches, and creates a remote branch named 'trunk', which you
won't need.  The following steps will fix this up:</p>

<ol>
<li>Move the files in .git/refs/remotes/origin/tags to .git/refs/tags</li>
<li>Remove the .git/refs/remotes/origin/tags directory.</li>
<li>Move remaining files in .git/refs/remotes/origin/ to .git/refs/heads</li>
</ol>

<div>&nbsp;</div>

<p>If you have version 1.6 or later of reposurgeon, you don't need to
do this step manually, because the command
<command>gitsvnparse</command> will do it for you.</p>

<p>There are also two different projects named <code>svn2git</code>,
one at <a href="https://github.com/nirvdrum/svn2git">GitHub</a> and
one at <a href="https://gitorious.org/svn2git/">Gitorious</a>.</p>

<p>The GitHub one is a thin wrapper around git-svn that,
according to its documentation, does something quite like the fixup
described above. But it turns the remote tags into actual tag objects
rather than "lightweight" tags (which are really just a kind of
branch).  If you have a Ruby interpreter installed it is possibly
worth experimenting with.</p>

<p>The Gitorious one is undocumented and written in C++, which are
both good reasons to avoid it (C++ being overkill for a job naturally
done by a scripting language). I mention it only because you might
trip over it while looking for the GitHub version.</p>

<h1 id="cleanup">Step Two: Cleanup</h1>

<p>You should now have a git repository, but it is likely to have a
lot of cruft and conversion artifacts in it.  Here are some common
forms of cruft:</p>

<dl>
<dt><em style="bold">Metadata inserted by git-svn.</em></dt>
<dd><code>git-svn</code> inserts lines at the end of each commit
comment that refer back to the Subversion commit it is derived.  This
is necessary for live-gatewaying, and useful during one-shot
conversions, but you will probably not want it in the final repo.</dd>

<dt><em>Commits generated by <code>cvs2svn</code> to carry tag information.</em></dt>  
<dd>These may be present even if you are not converting from CVS; they
lurk in the history of a lot of Subversion projects.  Sometimes these
junk commits are empty (no file operations associated with them at
all); sometimes they're translated as long lists of spurious delete
fileops, and sometimes they have actual file content (often referring
randomly to file versions far older than the junk commit). Older versions
of <code>cvs2svn</code> seem to have generated all kinds of meaningless
crud into these.</dd>

<dt><em>Commits generated by <code>git-svn</code> to carry tag information.</em></dt>  
<dd>Yes, these are a different phenomenon from cvs2svn-generated tag
commits. These are tip commits carrying a tag which have no
file-operation content.</dd>

<dt><em>Subversion and CVS commit references</em></dt> 
<dd>Often Subversion will be in the form 'r' followed by a string of
digits referring to a Subversion commit number. But not always; humans
come up with lots of ambiguous ways to write these.  CVS commit
references are even harder to spot mechanically, as they're just
groups of digits separated by dots with no identifing prefix.  A clean
conversion should turn all these into VCS-indpendent commit
references, which I'll describe later in this document.</dd>

<dt><em>Multiline contents with no summary</em></dt>
<dd>git and hg both encourage comments to begin with a summary line
that can stand alone as a short description of the change; this
practice produces more readable output from <code>git log</code>
and <code>hg log</code>. For a really high-quality conversion, 
multiline comments should be edited into this form.</dd>

<dt><em>Missing 'R' file operations</em></dt>
<dd>Some VCSes don't represent file rename operations, creating
pairs of file deletes and adds instead, and DVCS conversion tools won't
necessarily turn these pairs into rename operations. This happens
in particular with Subversion and gitsvnparse.</dd>
</dl>

<h2 id="reposurgeon">Using reposurgeon</h2>

<p>You can use <a
href="http://www.catb.org/esr/reposurgeon/">reposurgeon</a> to clean
up all these sorts of problems; it's specifically designed for this
job. The remainder of this section explains <code>reposurgeon</code> 
commands for common problems; the tool has a lot of additional power
for dealing with unusual situations</p>

<p>(The descriptions below apply to reposurgeon 1.6 and later.
The command set was significantly different in earlier versions.)</p>

<p>The <code>cvspurge</code> command removes most cvs2svn artifacts.
Specifically, it makes all junk commits generated to carry tags into
actual git tag objects. Then it removes all those that are either
empty or have fileop lists consisting entirely of deletes.</p>

<p>The <code>gitsvnparse</code> command parses git-svn metadata lines
and makes the Subversion revision number from them a property of the
commit. In versions 1.8 or later of reposurgeon this command also
converts delete-add pairs into renames when possible, and lifts
tag commits generated by git-svn into actual tag objects.</p>

<p>The <code>edit</code> command is also good for (1) fixing up up multiline
comments and (2) tweaking the comments on the tag objects generated
by the <code>cvslift</code> step.  In reposurgeon 1.8 or later, try
"edit multiline".</p>

<p>The command <code>list /cvs2svn/</code> will show you all remaining
<code>cvs2svn</code> artifacts.  Some can be deleted; a clue to look
for is junk commits generated to carry a tag at branch tips that have
one or two M fileops referring to a blob much earlier than the commit.
Very occasionally the generated commits will have real fileops on
them; all you can do in this case is note conversion damage in the
comment and move on.</p>

<p>Also, read the documentation of the <code>references</code>
command; reposurgeon has facilities for reference-lifting - fixing up
Subversion and CVS changeset references in comments so they're still
meaningful.</p>

<p>Experiments with reposurgeon suggest that <code>git import</code>
doesn't try to pack or otherwise optimize for space when it populates
a repo from a dump file; this produces large repositories.  Running
<code>gt repack</code> and <code>git gc
&#45;&#45;aggressive</code> can slim them down quite a lot.</p>

<h2 id="conversion-comments">Conversion comments</h2>

<p>Sometimes, in converting a repository, you may need to insert an
explanatory comment - for example, if metadata has been garbled or
missing and you need to point to that fact.</p>

<p>It's helpful for repository-browsing tools if there is a uniform
syntax for this that is highly unlikely to show up in repository
comments.  I recommend enclosing translation notes in [[ ]].  This 
has the advantage of being visually similar to the [ ] traditionally
used for editorial comments in text.</p>

<p> It is good practice to include, in the root commit of the
repository, a note dating and attributing the conversion work and
explaining these conventions.  Example:</p>

<blockquote>
[[This repository was converted from Subversion to git on 2011-10-24
by Eric S. Raymond <esr@thyrsus.com>.  Here and elsewhere, conversion
notes are enclosed in double square brackets. Junk commits generated
by cvs2svn have been removed, commit references have been mapped into
a uniform VCS-independent syntax, and some comments edited into
summary-plus-continuation form.]]
</blockquote>

<h2 id="recovery">Recovering from error</h2>

<p>Occasionally you'll discover problems with a conversion after you've
pushed it to a project's hosting site, typically to a bare repo that
the hosting software created for you.  Here's how to cope:</p>

<ol>
<li><p>Do your surgery on a copy of the repo with its .git/config
pointing to the public location.</p></li>

<li><p>Warn the public repo's users that it is briefly going out 
of service and they will need to re-clone it afterwards!</em></p></li>

<li><p>From your modified local repo, try 

<pre><code> 
git push -f origin HEAD:master
</code></pre>
<div>&nbsp;</div>

to push the new history up to the public repo. This will work if the
public repo is not locked against non fast-forward updates; otherwise,
try the next step.</p> </li>

<li><p>Re-initialize the public repo. You'll need ssh addess to the bare repo
directory on the host - let's suppose it's 'myproject'. Pop up to the
enclosing directory and do this:

<pre><code>
    mv myproject myproject-save
    rm -fr myproject-save/*
    git init &#45;&#45;bare myproject-save
    mv myproject-save myproject
</code></pre>
<div>&nbsp;</div>

The point of doing it this way is (a) so you never actually remove
myproject (on many hosts you will not have create permissions in the
enclosing directory), and (b) so no user can update the repo while 
you're clearing it (mv is atomic).</p>

<p>After re-initializing, you should be able to run <code>git
push</code> to push the new history up to the public repo.</p></li>

<li><p>Inform the public repo's users that it is available and remind
them that they will need to re-clone it.</p></li>
</ol>

<h1 id="client-tools">Step Three: Client Tools</h1>

<p>Developers who are already git fans and know how to use a git
client will, of course, have no partiticular trouble using a git
repository.</p>

<p>Windows users accustomed to working through TortoiseSVN can move to
<a href="http://code.google.com/p/tortoisegit/">TortoiseGIT</a>.</p>

<p>Developers who like hg can use the <a
href="http://hg-git.github.com/">hg-git mercurial plugin</a>. There is
an Ubuntu package "mercurial-git" for this, and other distributions
are likely to carry it as well.</p>

<p>There are some hg-git limitations to be aware of. In order
to simulate git behavior, hg-git keeps some local state in the
.hg directories; a map from git branch names to Mercurial commits,
a list of Mercurial bookmarks describing git branches (which
have bookmark-like behavior different from a Mercurial named branch) and a
file mapping git SHA1 hashes to hg SHA1 hashes (both systems 
use them as commit IDs).  The problem is that hg doesn't
copy any of this local state when it clones a repo, so clones
of hg-git repos lose their branches and tags.</p>

<h1 id="practice">Step Four: Good Practice</h1>

<p>Since the object of this exercise is to support both git and hg
fans, both groups need to use the repo in a way that doesn't assume
other will understand artifacts (like commit hashes) that are specific
to either VCS.</p>

<p>Being careful about this has an additional benefit.  Someday your
project may need to change VCSes yet again; on that day, it will be
extremely helpful if nobody has to try to convert years' or decades' 
worth of VCS-specific magic cookies in the history.</p>

<p>Educate your developers in the following good practices:</p>

<h2 id="references">Commit references</h2>

<p>The combination of a committer email address with a ISO8601
timestamp is a good way to refer to a commit without being
VCS-specific.  Thus, instead of "commit 304a53c2",
"2011-10-25T15:11:09Z!fred@foonly.com". I recommend that you <em>not
vary from this format</em>, even in trivial ways like omitting the 'Z'
or changing the 'T' or '!'. Making these cookies uniform and
machine-parseable will have good consequences for future
repository-browsing tools. The reference-lifting code in
<command>reposurgeon</command> generates them.</p>

<p>Sometimes it's enough to quote the summary line of a commit. So,
instead of "Back out most of commit 304a53c2", you might write 
"Back out 'Attempted divide-by-zero fix'.".</p>

<p>When appropriate. "my last commit" is simple and effective.</p>

<h2 id="comment-format">Comment summary lines</h2>

<p>As previously noted, git and hg both want comments to begin with a
summary line that can stand alone as a short description of the
change; this may optionally be followed by a aeparating blank line
and details in whatever form the commenter likes.</p>

<p>Try to end summary lines with a period.  Ending punctuation other
than a period should be used to indicate that the summary line is
incomplete and continues after the separator; "..." is conventional.

<p>For best results, stay within 72 characters per line.  Don't go
over 80.</p>

<p>Good comment practice produces more readable output from <code>git
log</code> and <code>hg log</code>, and makes it easy to take in
whole sequences of changes at a glance.</p>

</div>
<hr />
</body>
</html>
<!--
Local Variables:
compile-command: "(cd ~/WWW; upload dvcs-migration-guide.html)"
End:
-->

