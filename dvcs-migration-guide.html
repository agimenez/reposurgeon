<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rev="made" href="mailto:esr@snark.thyrsus.com" />
<link rel="stylesheet" href="/~esr/sitestyle.css" type="text/css" media='all'/>
<link rel="stylesheet" href="/~esr/sitestyle-print.css" type="text/css" media='print'/>
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="MSSmartTagsPreventParsing" content="TRUE" />
<a href='http://www.anti-leech.com/spam/spambot_stopper.php'></a>
<title>DVCS migration: supporting git and hg access from one repo</title>
</head>
<body>

<div id="Header">
<table width="100%" cellpadding="0" summary="Canned page header">
<tr>
<td>
<script language="JavaScript">
<!-- 
document.writeln(document.title);
 // -->
</script>
</td>
<td align="right">
<script language="JavaScript" src="/~esr/datestamp.js" type='text/javascript'></script>
</td>
</tr>
</table>
</div>

<div id="Menu">
	<hr/>
	<a href="/~esr" title="My home page">Home Page</a><br />
	<a href="/~esr/whatsnew.html" title="What's new on this site">What's New</a><br />
	<a href="/~esr/sitemap.html" title="Map of the site">Site Map</a><br />
	<a href="/~esr/software.html" title="Software I maintain">Software</a><br />
	<a href="/~esr/projects.html" title="My projects">Projects</a><br />
	<a href="/~esr/faqs/" title="My FAQ documents">HOWTOs</a><br />
	<a href="/~esr/writings/" title="Essays and ruminations">Essays</a><br />
	<a href="/~esr/personal.html" title="Portrait of the author">Personal</a><br />
	<a href="http://www.ibiblio.org/esrblog/">Weblog</a><br/>	
	<a href="/~esr/netfreedom/">Freedom!</a><br />
	<a href="/~esr/guns/">Firearms!</a><br />
	<hr/>
</div>

<div id="Content">

<h1 id="overview">Overview</h1>

<p>Distributed version control systems (DVCSes) are powerful and
liberating tools for software developers, but projects aiming to
choose one of the major contenders can find themselves mired in
contention and politics.  The most common such controversy is whether
to use git or hg (aka Mercurial).  With a little planning it's
possible to have it both ways, allowing developers to use either git
or hg to work with the same repository.</p>

<p>This page is a guide to up-converting your repository, finding the
tools you need, and adopting practices that will reduce process and
political friction to a minimum.</p>

<p>The technical fact central to the strategy I'm going to describe is
that as of late 2011 an hg plugin already exists to allow seamless
access to a git repository - but the reverse is not true.  So we'll
walk through how to up-convert a git repository and then line up the
tools to access it in several different ways.</p>

<p>This assumption may become false in the future.  The <a
href="https://github.com/rfk/git-remote-hg">git-remote-hg</a> project
seems to be attempting seamless live gatewaying in the other direction
(that is, using hg repos as git remotes). But as I write it seems to
be in early development and as yet only poorly documented.</p>

<p>But tools aren't the end of the story. Your developers will need
some education in good practice to get the most out of the tools.
I'll cover that aspect as well.</p>

<h1 id="conversion">Step One: Conversion</h1>

<p>Your first step will be converting your repository to git. In 90%
of cases you'll be converting from CVS or Subversion, and those are
the cases we'll cover here.  If you're using something older or
weirder, you're on your own for this step.</p>

<p>Before you can do your conversion, you'll need to put together an
authors file.  Subversion and CVS identify users by a local Unix login
name; DVCSes use pairs of fullnames and email addresses. The authors file
should specify a full name and email address for each local user ID in
your repo. Each line should be in the following form:</p>

<pre>
foonly=Fred Foonly &lt;foonly@foobar.com&gt;
</pre>

<h2 id="cvs_to_git">CVS to git</h2> 

<p>If you are using CVS, you have (at least) two conversion options.
Under most circumstances, the best option is to use the cvsimport
plugin of git itself.  I recommend passing it the following options:</p>

<dl>
<dt>-s '~'</dt>
<dd>Map slashes in CVS tag names to tildes (or something else they
don't contain). git will cheerfully create directories beneath
.git/refs/tags, but this is not how most users expect tags to
look.</dd>
<dt>-u</dt>
<dt>Map underscores in tag names to periods. This is just cosmetic</dt>
<dt>-k</dt>
<dd>Suppress CVS keyword expansion.  As the manual page says, this
avoids a lot of tiny, noisy changesets.</dd>
<dt>-m</dt>
<dd>Attempt merge recognition by matching committer headers.</dd>
<dt>-A</dt>
<dd>Pass in your authors file.</dd>
<dt>-R</dt>
<dd>Tell it to generate a map of CVS revisions.</dd>
<dt>-z 90</dt>
<dd>Shorten the time interval within which CVS commits can be grouped
into changesets.  This makes the history noisier, but may protect you
if the clock on the system where the CVS repo was hosted was unstable;
in that situation it reduces the odds that <code>git cvsimport</code> 
will be confused by out-of-time-order commits.</dd>
<dt>-v</dt>
<dd>This tool runs for a while on large repositories; its default
silent mode can be disconcerting.</dd>
<dt>-C</dt>
<dd>Unpacking in the current directory is the default behavior, but
probably not what you want.</dd>
</dl>

<p>The reason this tool is normally your best option is that it
converts straight to git, avoiding issues produced by the other major
conversion tools which either go through Subversion as an intermediate
stage or have Subversion-based assumptions baked into them. Also, the
-R option is immensely helpful for reference-lifting. But read the
warnings on the manual page; under some (rare) circumstances this tool
can produce incorrect conversions.</p>

<p>Another option is the <a
href="http://cvs2svn.tigris.org/cvs2git.html">cvs2git</a> tool dervied
from cvs2svn.  The hard part - deducing changesets from CVS's per-file
commits - is shared with <code>cvs2svn</code>, which has probably been more
extensively battle-tested than any other CVS converter out there. The
drawbacks are (1) There is no -A option, and (b) your converted
history will contain the same sorts of cruft that cvs2svn generates
(see below).</p>

<p>I have done a test conversion of a CVS repo with ten years of
history with <code>cvs2git</code> and it seemed to work as well as
<code>cvs2svn</code> (but not as well as <code>git cvsimport</code>).
I had to git reset &#45;&#45;hard afterwards to actually materialize
the files in the working directory.</p>

<p>Finally, you can use <a
href="http://cvs2svn.tigris.org/cvs2svn.html">cvs2svn</a> to convert
from CVS to Subversion, then from Subversion to git. I've done this,
and it worked - but see the description of cvs2svn artifacts later on.
Use the -A option of <code>cvs2svn</code> (which works just like -A in
<code>git cvsimport</code>) to pass it your authors file.</p>

<h2 id="svn_to_git">Subversion to git</h2>

<p>There are at least half a dozen utilities out there for lifting
Subversion repositories to a git repository or import stream.  My
opinion of them can be gauged by the fact that I wrote my own.</p>

<p>2.0 and later versions of <a
href="http://www.catb.org/esr/reposurgeon/">reposurgeon</a> can parse
Subversion dumpfiles; given local access to a Subversion repository
(not a checkout, but the actual repository or a mrror of it) the tool
can use <code>svnadmin dump</code> to mine it. The reposurgeon
distribution also includes a script named <code>svngrab</code> for
grabbing and mirroring a remote Subversion repository.</p>

<p>Get the repository mirrored into a directory, fire up
<code>reposurgeon</code>, give it the "read" command with the
directory name as argument, and wait a few minutes while the baton
spins. When you get a prompt from <code>reposurgeon</code> again, you
can make a live repo in a scratch directory in your choice of the
systems <code>reposurgeon</code> can export to (including git), or
proceed directly to examining and editing the history.</p>

<p>Normally <code>reposurgeon</code> will do branch analysis for you.
On most Subversion repositories, and in particular anything with a
standard trunk/tags/branches layout, it will do the right thing. (It
will also cope with exiguous branches in the root directory of the
repo, such as many projects use for website content.)  In unusual
cases you may want to use the "svn_nobranch" option; find out more
about this and other options via the "set" command.</p>

<p>To my knowledge, <code>reposurgeon</code> is the only conversion
tool that handles multibranch Subversion repositories in full
generality. It can even translate Subversion commits that alter
multiple branches.</p>

<h1 id="cleanup">Step Two: Cleanup</h1>

<p>You should now have a git repository, but it is likely to have a
lot of cruft and conversion artifacts in it.  Here are some common
forms of cruft:</p>

<dl>
<dt><em>Subversion and CVS commit references</em></dt> 
<dd>Often Subversion references will be in the form 'r' followed by a
string of digits referring to a Subversion commit number. But not
always; humans come up with lots of ambiguous ways to write these.
CVS commit references are even harder to spot mechanically, as they're
just groups of digits separated by dots with no identifing prefix.  A
clean conversion should turn all these into VCS-independent commit
references, which I'll describe later in this document.</dd>

<dt><em>Multiline contents with no summary</em></dt>
<dd>git and hg both encourage comments to begin with a summary line
that can stand alone as a short description of the change; this
practice produces more readable output from <code>git log</code>
and <code>hg log</code>. For a really high-quality conversion, 
multiline comments should be edited into this form.</dd>

<dt><em>Branch tip deletes, deletealls, and unexpressed merges</em></dt> 
<dd>In Subversion it is common practice to delete a branch directory
when that line of development is finished or merged to trunk; this
makes sense because it reduces the checkout size of the repo in later
revisions. In a DVCS deletes at a branch tip don't save you any
storage, so it makes more sense to leave the branch with all of its
tip content live if you're not going to delete it entirely. Sometimes
editing a later commit to have the branch tip as a parent (creating
a merge that Subversion could not express) make sense; look for
svn:mergeinfo properties as clues.</dd>

<dt><em>Missing 'R' file operations</em></dt>
<dd>Some VCSes don't represent file rename operations, creating
pairs of file deletes and adds instead, and DVCS conversion tools won't
necessarily turn these pairs into rename operations. This happens
in particular with Subversion and git-svn.</dd>

<dt><em>Commits generated by <code>cvs2svn</code> to carry tag information.</em></dt>  
<dd>These may be present even if you are not converting from CVS; they
lurk in the history of a lot of Subversion projects.  Sometimes these
junk commits are empty (no file operations associated with them at
all); sometimes they're translated as long lists of spurious delete
fileops, and sometimes they have actual file content (duplicating
parent file versions, or referring
randomly to file versions far older than the junk commit). Older versions
of <code>cvs2svn</code> seem to have generated all kinds of meaningless
crud into these.</dd>

<dt><em style="bold">Metadata inserted by git-svn.</em></dt>
<dd><code>git-svn</code> inserts lines at the end of each commit
comment that refer back to the Subversion commit it is derived from.  This
is necessary for live-gatewaying, and useful during one-shot
conversions, but you will probably not want it in the final repo.</dd>

<dt><em>Commits generated by <code>git-svn</code> to carry tag information.</em></dt>  
<dd>Yes, these are a different phenomenon from cvs2svn-generated tag
commits. These are tip commits carrying a tag which have no
file-operation content.</dd>
</dl>

<p>The two kinds of git-svn cruft are only an issue if you're
starting from repository that has been preconverted with
<code>git-svn</code>, which is the procedure older versions of this
guide recommended.  Since its 2.0 version you can use
<code>reposurgeon</code> to read Subversion repos directly, which is a
better idea and avoids these problems.</p>

<h2 id="reposurgeon">Surgical cleanup using reposurgeon</h2>

<p>You can use <a
href="http://www.catb.org/esr/reposurgeon/">reposurgeon</a> to clean
up all these sorts of problems; it's specifically designed for this
job. The remainder of this section explains <code>reposurgeon</code> 
commands for common problems; the tool has a lot of additional power
for dealing with unusual situations</p>

<p>(The descriptions below apply to reposurgeon 1.6 and later.
The command set was significantly different in earlier versions.
Also note that the <code>cvspurge</code> and <code>gitsvnparse</code>
commands in versions up to 1.9 were obsoleted by the ability to read
Subversion repositories directly and have been removed. The equivalent
fixups are now done, and done better, at repository read time.)</p>

<p>Here's a checklist of manual cleanup steps. Tips on how to do them
with reposurgeon follow.</p>

<ol>
<li>Map author IDs from local to DVCS form.</li>
<li>Check for leftover cvs2svn junk commits and remove them if possible.</li>
<li>Lift references in commit comments.</p>
<li>Massage comments into summary-line-plus-continuation form.</li>
<li>Remove delete-only tip commits where appropriate.</li>
<li>Review generated tags, pruning as appropriate.</li>
<li>Look for branch merge points and patch parent marks to make them.</li>
<li>Fix up or remove $-keyword cookies in the latest revision.</li>
<li>If there's a root branch, check for and remove junk commits on it.</li>
<li>For the record, make a commit noting time and date of the repo lift.</li>
<li>If your target was git, run  <code>git gc &#45;&#45;aggressive</code>.</li>
</ol>

<p><code>reposurgeon</code> has a "script" command that allows you to
bundle up a set of commands with comments.  I recommend writing your
repository list as a reposurgeon script; this helps you not lose older
steps as you experiment with newer ones, and it documents what you did.</p>

<p>Most of the work will be in the comment-fixup and reference-lifting
stages. I find, however, that they normally takes only a couple of
hours even on very large repos with thousands of commits. An entire
conversion is usually less than a day of work.</p>

<p>You can use the <code>authors read</code> command to perform the
author-ID mapping operation with <code>reposurgeon</code>.</p>

<p>The command <code>list /cvs2svn/</code> will show you all remaining
<code>cvs2svn</code> artifacts.  Some can be deleted; a clue to look
for is junk commits generated to carry a tag at branch tips that have
one or two M fileops referring to a blob much earlier than the commit.
Very occasionally the generated commits will have real fileops on
them; all you can do in this case is note conversion damage in the
comment and move on.</p>

<p>See the documentation of the <code>references</code> command; for
details on how fix up Subversion and CVS changeset references in
comments so they're still meaningful.</p>

<p>The <code>edit multiline</code> command is good for fixing up
multiline comments.</p>

<p>The <code>reposurgeon</code> command <code>inspect =H</code> will
show you tip commits which may contain only deletes and
deletealls.</p>

<p>Tags can be inspected with <code>inspect =T</code>. Junk tags can
be removed with the <code>delete</code> commmand. Tag comments can be
modified with <code>edit</code>.

<p>Version 2.x and later of <code>reposurgeon</code> have a new
<code>merge</code> command spercifically for performing branch merges.
The <code>edit</code> command will also allow you to add a parent mark
to a commit.</p>

<p>One minor feature you lose in moving from CVS or Subversion to a
DVCS is keyword expansion.  You should go through the last revision of
the code and remove $Id$, $Date$, $Revision$, and other keyword
cookies lest they become unhelpful fossils. A command like <code>grep -R
'$[A-Z]' .</code> may be helpful.</p>

<p>After conversion of a branchy repository, look to see if there is a 
'root' branch.  If there are any commits with a sufficiently
pathological structure that <code>reposurgeon</code> can't figure out
what branch they belong to, they'll wind up there. Certain odd
combinations of Subversion branch creation and deletion operations may
do this, producing spurious deleteall commits; the results have to
be garbage-collected by hand.</p>

<p>It's good practice to leave a commit in the stream noting the date 
and time of the repo lift.  See the next section on conversion
comments for discussion.</p>

<p>Experiments with reposurgeon suggest that <code>git import</code>
doesn't try to pack or otherwise optimize for space when it populates
a repo from a dump file; this produces large repositories.  Running
<code>gt repack</code> and <code>git gc
&#45;&#45;aggressive</code> can slim them down quite a lot.</p>

<h2 id="conversion-comments">Conversion comments</h2>

<p>Sometimes, in converting a repository, you may need to insert an
explanatory comment - for example, if metadata has been garbled or
missing and you need to point to that fact.</p>

<p>It's helpful for repository-browsing tools if there is a uniform
syntax for this that is highly unlikely to show up in repository
comments.  I recommend enclosing translation notes in [[ ]].  This 
has the advantage of being visually similar to the [ ] traditionally
used for editorial comments in text.</p>

<p> It is good practice to include, in the root commit of the
repository, a note dating and attributing the conversion work and
explaining these conventions.  Example:</p>

<blockquote>
[[This repository was converted from Subversion to git on 2011-10-24
by Eric S. Raymond <esr@thyrsus.com>.  Here and elsewhere, conversion
notes are enclosed in double square brackets. Junk commits generated
by cvs2svn have been removed, commit references have been mapped into
a uniform VCS-independent syntax, and some comments edited into
summary-plus-continuation form.]]
</blockquote>

<p>You should also, as previously noted, leave a comment in the normal
commit sequence noting the switchover.</p>

<h2 id="recovery">Nonsurgical cleanup steps</h2>

<p>You'll want to run through the repository removing
CVS and Subversion keyword-expansion headers.  "grep -R '\\$[A-Z]' ."
will turn these up.  Note that if you've been relying on these
to supply version strings that are visible at runtime, you will
need to supply that information in some different way.</p>

<p>A step that too often gets missed and then inelegantly patched in
later is converting the declarations that tell the
version-control system to ignore derived files.</p>

<p>The format of .gitignore is compatible with .cvsignore; after a
CVS-to-git conversion you'll want to do something like this:</p> 

<pre><code>
for x in `find . -print | grep cvsignore`; do t=`dirname $x`/.gitignore; git mv $x $t; done
git commit -m 'Convert each .cvsignore to a .gitignore.'
</code></pre>

<p>Moving Subversion ignore properties is easier, as git-svn has direct
support for this:</p>

<pre><code>
git svn show-ignore >.gitignore
git add .gitignore
git commit -m 'Convert svn:ignore properties to .gitignore.'
</code></pre>

<h2 id="recovery">Recovering from error</h2>

<p>Occasionally you'll discover problems with a conversion after you've
pushed it to a project's hosting site, typically to a bare repo that
the hosting software created for you.  Here's how to cope:</p>

<ol>
<li><p>Do your surgery on a copy of the repo with its .git/config
pointing to the public location.</p></li>

<li><p>Warn the public repo's users that it is briefly going out 
of service and they will need to re-clone it afterwards!</em></p></li>

<li><p>From your modified local repo, try 

<pre><code> 
git push -f origin HEAD:master
</code></pre>
<div>&nbsp;</div>

to push the new history up to the public repo. This will work if the
public repo is not locked against non fast-forward updates; otherwise,
try the next step.</p> </li>

<li><p>Re-initialize the public repo. You'll need ssh addess to the bare repo
directory on the host - let's suppose it's 'myproject'. Pop up to the
enclosing directory and do this:

<pre><code>
    mv myproject myproject-hidden
    rm -fr myproject-hidden/*
    git init &#45;&#45;bare myproject-hidden
    mv myproject-hidden myproject
</code></pre>
<div>&nbsp;</div>

The point of doing it this way is (a) so you never actually remove
myproject (on many hosts you will not have create permissions in the
enclosing directory), and (b) so no user can update the repo while 
you're clearing it (mv is atomic).</p>

<p>After re-initializing, you should be able to run <code>git
push</code> to push the new history up to the public repo.</p></li>

<li><p>Inform the public repo's users that it is available and remind
them that they will need to re-clone it.</p></li>
</ol>

<h1 id="client-tools">Step Three: Client Tools</h1>

<p>Developers who are already git fans and know how to use a git
client will, of course, have no partiticular trouble using a git
repository.</p>

<p>Windows users accustomed to working through TortoiseSVN can move to
<a href="http://code.google.com/p/tortoisegit/">TortoiseGIT</a>.</p>

<p>Developers who like hg can use the <a
href="http://hg-git.github.com/">hg-git mercurial plugin</a>. There is
an Ubuntu package "mercurial-git" for this, and other distributions
are likely to carry it as well.</p>

<p>There are some hg-git limitations to be aware of. In order to
simulate git behavior, hg-git keeps some local state in the .hg
directories; a map from git branch names to Mercurial commits, a list
of Mercurial bookmarks describing git branches (which have
bookmark-like behavior different from a Mercurial named branch) and a
file mapping git SHA1 hashes to hg SHA1 hashes (both systems use them
as commit IDs).  The problem is that hg doesn't copy any of this local
state when it clones a repo, so clones of hg-git repos lose their
git branches and tags.</p>

<h1 id="practice">Step Four: Good Practice</h1>

<p>Since the object of this exercise is to support both git and hg
fans, both groups need to use the repo in a way that doesn't assume
the other group will understand artifacts (like commit hashes) that
are specific to either VCS.</p>

<p>Being careful about this has an additional benefit.  Someday your
project may need to change VCSes yet again; on that day, it will be
extremely helpful if nobody has to try to convert years' or decades' 
worth of VCS-specific magic cookies in the history.</p>

<p>Educate your developers in the following good practices:</p>

<h2 id="references">Commit references</h2>

<p>The combination of a committer email address with a ISO8601
timestamp is a good way to refer to a commit without being
VCS-specific.  Thus, instead of "commit 304a53c2",
"2011-10-25T15:11:09Z!fred@foonly.com". I recommend that you <em>not
vary from this format</em>, even in trivial ways like omitting the 'Z'
or changing the 'T' or '!'. Making these cookies uniform and
machine-parseable will have good consequences for future
repository-browsing tools. The reference-lifting code in
<command>reposurgeon</command> generates them.</p>

<p>Sometimes it's enough to quote the summary line of a commit. So,
instead of "Back out most of commit 304a53c2", you might write 
"Back out 'Attempted divide-by-zero fix'.".</p>

<p>When appropriate. "my last commit" is simple and effective.</p>

<h2 id="comment-format">Comment summary lines</h2>

<p>As previously noted, git and hg both want comments to begin with a
summary line that can stand alone as a short description of the
change; this may optionally be followed by a aeparating blank line
and details in whatever form the commenter likes.</p>

<p>Try to end summary lines with a period.  Ending punctuation other
than a period should be used to indicate that the summary line is
incomplete and continues after the separator; "..." is conventional.

<p>For best results, stay within 72 characters per line.  Don't go
over 80.</p>

<p>Good comment practice produces more readable output from <code>git
log</code> and <code>hg log</code>, and makes it easy to take in
whole sequences of changes at a glance.</p>

<h1 id="history">Revision history</h1>

<p>1.0 (2011-10-25) Original version.</p>

<p>2.0 (2011-11-04) Much more about CVS-to-git conversion, including
recommending <code>git cvsimport</code>. I started numbering versions
at this point.</p>

<p>2.1 (2011-11-07) Updated for reposurgeon 1.7.</p>

<p>2.2 (2011-11-10) Updated for reposurgeon 1.8.</p>

<p>2.3 (2011-11-10) Fix incorrect assertion about newer versions of
git handling properties, this was a failure in my testing.<p>

<p>2.4 (2011-11-16) Add section on post-surgical cleanup: moving
ignores, removing keyword expansions.</p>

<p>2.5 (2011-11-25) Fix typos and note the existence of git-remote-hg</p>

<p>2.6 (2011-11-26) reposurgeon can read Subversion repos now, making
earlier conversion tools obsolete.</p>
</div>
<hr />
</body>
</html>
<!--
Local Variables:
compile-command: "(cd ~/WWW; upload dvcs-migration-guide.html)"
End:
-->
