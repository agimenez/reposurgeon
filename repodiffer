#!/usr/bin/env python
#
# Compare git repositories or fast-import streams for differences.

import sys, os, getopt, subprocess, time, tempfile, difflib, shutil, re

DEBUG_GENERAL  = 1
DEBUG_PROGRESS = 2
DEBUG_COMMANDS = 3

class Fatal(Exception):
    "Unrecoverable error."
    def __init__(self, msg):
        Exception.__init__(self)
        self.msg = msg

def do_or_die(dcmd, legend=""):
    "Either execute a command or raise a fatal exception."
    if legend:
        legend = " "  + legend
    if verbose >= DEBUG_COMMANDS:
        sys.stdout.write("repodiffer: executing '%s'%s\n" % (dcmd, legend))
    try:
        retcode = subprocess.call(dcmd, shell=True)
        if retcode < 0:
            raise Fatal("repodiffer: child was terminated by signal %d." % -retcode)
        elif retcode != 0:
            raise Fatal("repodiffer: child returned %d." % retcode)
    except (OSError, IOError) as e:
        raise Fatal("repodiffer: execution of %s%s failed: %s" % (dcmd, legend, e))

def capture_or_die(dcmd, legend=""):
    "Either execute a command and capture its output or die."
    if legend:
        legend = " "  + legend
    if verbose >= DEBUG_COMMANDS:
        sys.stdout.write("repodiffer: executing '%s'%s\n" % (dcmd, legend))
    try:
        return subprocess.check_output(dcmd, shell=True)
    except subprocess.CalledProcessError as e:
        if e.returncode < 0:
            raise Fatal("repodiffer: child was terminated by signal %d." % -e.returncode)
        elif e.returncode != 0:
            sys.stderr.write("repodiffer: child returned %d." % e.returncode)
        sys.exit(1)

class directory_context:
    def __init__(self, target):
        self.target = target
        self.source = None
    def __enter__(self):
        self.source = os.getcwd()
        os.chdir(self.target)
    def __exit__(self, extype, value_unused, traceback_unused):
        os.chdir(self.source)

class Commit:
    def __init__(self, repo, text):
        self.repo = repo
        self.text = text
        self.commit = None
        self.tree = self.author = self.committer = self.comment =  None
        self.authordate = self.commitdate = None
        self.matched = False
        for line in text.split("\n"):
            if line.startswith("commit "):
                self.commit = line.strip().split()[1]
            elif line.startswith("parent "):
                continue
            elif line.startswith("tree "):
                self.tree = line.strip().split()[1]
            elif line.startswith("author "):
                (self.author, self.authordate) = Commit.date_extract(line[7:])
            elif line.startswith("committer "):
                (self.committer, self.commitdate) = Commit.date_extract(line[10:])
            elif not line:
                if self.comment == None:
                    self.comment = ""
            else:
                if self.comment is not None:
                    self.comment += line + "\n"
            assert self.commit and self.parts()
        self.mark = None
    def timestamp(self):
        "UTC timestamp of commit."
        return int(self.commitdate.split()[0])
    @staticmethod
    def date_extract(text):
        "Extract a git-format date"
        ee = text.rindex(">")
        return (text[:ee+1], text[ee+2:])
    @staticmethod
    def time_not_equal(a, b):
        "Time equality check, which sometimes wants to ignore timezone skew."
        if "timezone" in ignores:
            return int(a.split()[0]) % 360 != int(b.split()[0]) % 360
        else:
            return a != b
    def __str__(self):
        "Generate an ID for this commit that is useful to humans."
        if self.repo.streamed:
            return self.mark
        elif fullhash:
            return self.commit
        else:
            return self.commit[:7]
    def __repr__(self):
        r = "commit %s\n" % str(self)
        r += "committer %s %s\n" % (self.committer, self.commitdate)
        r += "author %s %s\n" % (self.author, self.authordate)
        r += "tree %s\n" % self.tree
        r += self.comment
        return r
    def parts(self):
        return (self.tree,
                self.author, self.authordate,
                self.committer, self.commitdate,
                self.comment)
    def difference(self, other):
        res = []
        # Alas, there's no better way to do this than with an ignores global
        if "author" not in ignores and self.author != other.author:
            res.append('author')
        if "authordate" not in ignores and \
               Commit.time_not_equal(self.authordate, other.authordate):
                res.append('authordate')
        if "committer" not in ignores and self.committer != other.committer:
            res.append('committer')
        if "commitdate" not in ignores \
               and Commit.time_not_equal(self.commitdate, other.commitdate):
                res.append('commitdate')
        if "comment" not in ignores and self.comment != other.comment:
            res.append('comment')
        if "tree" not in ignores and self.tree != other.tree:
            res.append('tree')
        return res
    def __hash__(self):
        return hash(self.parts())
    def __eq__(self, other):
        return not self.difference(other)

class Repository:
    "A repository, for comparison purposes."
    def __init__(self, sourcepath):
        self.path = sourcepath
        # Accept either a repository directory or an import stream
        if os.path.isdir(self.path):
            self.streamed = False
            self.directory = self.path
        elif os.path.isfile(self.path):
            self.streamed = True
            self.directory = tempfile.mkdtemp()
            source = os.path.abspath(self.path)
            with directory_context(self.directory):
                do_or_die("git init --quiet; git fast-import --quiet --export-marks=.git/marks <%s" % source)
        else:
            raise Fatal("repodiffer: I don't know how to turn %s into a repo.")
        # Get a list of metadata and tree signatures for this repo
        with directory_context(self.directory):
            log = capture_or_die("git log --all --reverse --date-order --format=raw")
            # Ugh.  This split logic is ugly.  Is there a better way?
            self.signature = [Commit(self, "commit %s\n" % el) for el in log.split("\ncommit ")]
            if self.signature:
                self.signature.pop(0)
                self.signature[-1].text = self.signature[-1].text[:-1]
            self.mark_to_sha1 = {}
            self.sha1_to_mark = {}
            try:
                for line in open(".git/marks"):
                    (mark, sha1) = line.strip().split()
                    self.sha1_to_mark[sha1] = mark
                    self.mark_to_sha1[mark] = sha1
                for item in self.signature:
                    item.mark = self.sha1_to_mark[item.commit]
            except (IOError, OSError):
                pass
        # TODO: Also get a list of annotated tags
    def lookup(self, name):
        "Look up an object by name."
        for commit in self.signature:
            if commit.commit.startswith(name) or commit.mark == name:
                return commit
        else:
            return None
    def sort(self):
        "Sort by Committer-Date in case commits were generated in topo order."
        self.signature.sort(key=lambda c: c.timestamp())
    def __str__(self):
        return "<%s: %s>" % (self.path, self.signature)
    def __del__(self):
        if self.streamed:
            os.system("rm -fr " + self.directory)

def diff_single(single, alpha, beta):
    "Examine the difference between two specified commits."
    try:
        (a, b) = single.split("=")
    except ValueError:
        sys.stderr.write("repodiffer: need hashes or marks separated by =\n")
        sys.exit(1)
    ac = alpha.lookup(a)
    if ac is None:
        sys.stderr.write("repodiffer: no match for %s\n" % a)
        sys.exit(1)
    bc = beta.lookup(b)
    if bc is None:
        sys.stderr.write("repodiffer: no match for %s\n" % b)
        sys.exit(1)
    sys.stdout.write("differences: %s\n" % (ac.difference(bc),))
    sys.stdout.write("from:\n%s" % repr(ac))
    sys.stdout.write("to:\n%s" % repr(bc))

def diff_walk(alpha, beta):
    "Walk through time-ordered commit pairs, finding differences."
    # Experimental, undocumented
    alpha.sort()
    beta.sort()
    i = 0
    tied = []
    for a in alpha.signature:
        for b in beta.signature:
            if a.comment == b.comment:
                tied.append((a, b))
                a.matched = b.matched = True 
    print "repodiffer: %d comments can be tied together of %d vs %d objects." \
          % (len(tied), len(alpha.signature), len(beta.signature))
    i = j = 0
    # Build the pairing table.
    # Requires that matched alpha and beta commits have the same ordering
    pairs = []
    while i < len(alpha.signature) and j < len(beta.signature):
        a = alpha.signature[i]
        b = beta.signature[j]
        if (a, b) in tied:
            pairs.append((a, b))
            i += 1
            j += 1
        elif a.matched and b.matched:
            sys.stderr.write("repodiff: matches are out of order at %d:%d\n" \
                             % (i+1, j+1))
            print repr(a)
            print repr(b)
            sys.exit(1)
        if a.matched and not b.matched:
            pairs.append((None, b))
            j += 1
        if b.matched and not a.matched:
            pairs.append((a, None))
            i += 1
        if not a.matched and not b.matched:
            if a.timestamp() <= b.timestamp():
                pairs.append((a, None))
                pairs.append((None, b))
            else:
                pairs.append((a, None))
                pairs.append((None, b))
            i += 1
            j += 1
    # Report on the pair table
    for (a, b) in pairs:
        if a is None or b is None:
            print "%s -> %s" (a, b)
        else:
            print "%s -> %s: %s" % (a, b, a.difference(b))

def diff_all(alpha, beta):
    "Diff the entire repositories."
    alpha.sort()
    beta.sort()
    differ = difflib.SequenceMatcher(isjunk=None, autojunk=False)
    differ.set_seqs(alpha.signature, beta.signature)
    n_alpha = n_beta = 0
    n_equal = n_replacements = n_deletions = n_insertions = 0
    for (op, slo, shi, tlo, thi) in differ.get_opcodes():
        if op == 'equal':
            eqcount = (shi - slo)
            n_equal += eqcount
            n_alpha += eqcount
            n_beta += eqcount
            if showequal:
                sourcecommit = alpha.signature[source]
                targetcommit = beta.signature[target]
                sys.stdout.write("equal: %s = %s\n" % (sourcecommit, targetcommit))
        elif op == 'replace':
            for (source, target) in zip(range(slo, shi), range(tlo, thi)):
                n_replacements += 1
                n_alpha += 1
                n_beta += 1
                sourcecommit = alpha.signature[source]
                targetcommit = beta.signature[target]
                sys.stdout.write("changed: %s -> %s in %s.\n" % (sourcecommit, targetcommit, ",".join(sourcecommit.difference(targetcommit))))
        elif op == 'delete':
            for source in range(slo, shi):
                n_deletions += 1
                n_alpha += 1
                sourcecommit = alpha.signature[source]
                sys.stdout.write("deleted: %s\n" % sourcecommit)
        elif op == 'insert':
            for target in range(tlo, thi):
                n_insertions += 1
                n_beta += 1
                targetcommit = beta.signature[target]
                sys.stdout.write("inserted: %s\n" % targetcommit)
        else:
            sys.stdout.write("unexpected opcode: %s\n" \
                             % ((op, slo, shi, tlo, thi),))
    if n_replacements or n_deletions or n_insertions:
        sys.stdout.write("statistics: %d equal, %d of %d inserted, %d of %d deleted.\n"
                         % (n_equal,
                            n_insertions,
                            n_beta,
                            n_deletions,
                            n_alpha))
        sys.exit(1)
    else:
        sys.exit(0)

if __name__ == '__main__':
    if sys.hexversion < 0x02070000:
        sys.stderr.write("git-weave: requires Python 2.7 or later.")
        sys.exit(1)
    (options, arguments) = getopt.getopt(sys.argv[1:], "efi:s:vw", ["showequal", "fullhash", "ignore=", "single=", "verbose=", "walkdiff"])
    alpha = None
    beta = None
    showequal = False
    fullhash = False
    ignores = ""
    single = None
    verbose = 0
    walkdiff = False
    for (opt, val) in options:
        if opt == '-e' or opt == '--showequal':
            showequal = True
        elif opt == '-f' or opt == '--fullhash':
            fullhash = True
        elif opt == '-i' or opt == '--ignore':
            ignores = val
        elif opt == '-s' or opt == '--single':
            single = val
        elif opt == '-v' or opt == '--verbose':
            verbose = int(val)
        elif opt == '-w' or opt == '--walkdiff':
            walkdiff = True
    if len(arguments) < 2:
        sys.stderr.write("repodiffer: input and output directory or import-stream arguments are required.\n")
        sys.exit(1)
    else:
        (alpha, beta) = arguments[:2] 
    if not os.path.exists(alpha):
        sys.stderr.write("repodiffer: %s must exist.\n" % alpha)
        sys.exit(1)
    if not os.path.exists(beta):
        sys.stderr.write("repodiffer: %s must exist.\n" % beta)
        sys.exit(1)
    if verbose >= DEBUG_PROGRESS:
        sys.stderr.write("repodiffer: compare %s to %s.\n" % (alpha, beta))
    try:
        alpha = Repository(alpha)
        beta  = Repository(beta)
        if single:
            diff_single(single, alpha, beta)
        elif walkdiff:
            diff_walk(alpha, beta)
        else:
            diff_all(alpha, beta)
    except Fatal, err:
        sys.stderr.write(err.msg + "\n")
        sys.exit(1)
    except KeyboardInterrupt:
        pass

# end
