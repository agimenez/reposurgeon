#!/usr/bin/env python
#
# Compare git repositories or fast-import streams for differences.

import sys, os, getopt, subprocess, tempfile, hashlib

DEBUG_GENERAL  = 1
DEBUG_COMMANDS = 2
DEBUG_LOWLEVEL = 3

class Fatal(Exception):
    "Unrecoverable error."
    def __init__(self, msg):
        Exception.__init__(self)
        self.msg = msg

def do_or_die(dcmd, legend=""):
    "Either execute a command or raise a fatal exception."
    if legend:
        legend = " "  + legend
    if verbose >= DEBUG_COMMANDS:
        sys.stdout.write("repodiffer: executing '%s'%s\n" % (dcmd, legend))
    try:
        retcode = subprocess.call(dcmd, shell=True)
        if retcode < 0:
            raise Fatal("repodiffer: child was terminated by signal %d." % -retcode)
        elif retcode != 0:
            raise Fatal("repodiffer: child returned %d." % retcode)
    except (OSError, IOError) as e:
        raise Fatal("repodiffer: execution of %s%s failed: %s" % (dcmd, legend, e))

def capture_or_die(dcmd, legend=""):
    "Either execute a command and capture its output or die."
    if legend:
        legend = " "  + legend
    if verbose >= DEBUG_COMMANDS:
        sys.stdout.write("repodiffer: executing '%s'%s\n" % (dcmd, legend))
    try:
        return subprocess.check_output(dcmd, shell=True)
    except subprocess.CalledProcessError as e:
        if e.returncode < 0:
            raise Fatal("repodiffer: child was terminated by signal %d." % -e.returncode)
        elif e.returncode != 0:
            sys.stderr.write("repodiffer: child returned %d." % e.returncode)
        sys.exit(1)

class directory_context:
    def __init__(self, target):
        self.target = target
        self.source = None
    def __enter__(self):
        if verbose >= DEBUG_COMMANDS:
            sys.stdout.write("repodiffer: in %s...\n" % self.target)
        self.source = os.getcwd()
        if os.path.isdir(self.target):
            os.chdir(self.target)
        else:
            enclosing = os.path.dirname(self.target)
            if enclosing:
                os.chdir()
    def __exit__(self, extype, value_unused, traceback_unused):
        os.chdir(self.source)

class Commit:
    def __init__(self, repo, text):
        self.repo = repo
        self.text = text
        self.commit = None
        self.tree = self.author = self.committer = self.comment =  None
        self.authordate = self.commitdate = None
        self.matched = False
        for line in text.split("\n"):
            if line.startswith("commit "):
                self.commit = line.strip().split()[1]
            elif line.startswith("parent "):
                continue
            elif line.startswith("tree "):
                self.tree = line.strip().split()[1]
            elif line.startswith("author "):
                (self.author, self.authordate) = Commit.date_extract(line[7:])
            elif line.startswith("committer "):
                (self.committer, self.commitdate) = Commit.date_extract(line[10:])
            elif not line:
                if self.comment == None:
                    self.comment = ""
            else:
                if self.comment is not None:
                    self.comment += line + "\n"
            assert self.commit and self.parts()
        self.mark = None
    def timestamp(self):
        "UTC timestamp of commit."
        return int(self.commitdate.split()[0])
    def action_stamp(self):
        "A timestamp/committer pair.  Should be unique!"
        return(self.committer, self.timestamp())
    @staticmethod
    def date_extract(text):
        "Extract a git-format date"
        ee = text.rindex(">")
        return (text[:ee+1], text[ee+2:])
    @staticmethod
    def time_not_equal(a, b):
        "Time equality check, which sometimes wants to ignore timezone skew."
        if "timezone" in ignores:
            return int(a.split()[0]) % 360 != int(b.split()[0]) % 360
        else:
            return a != b
    def __str__(self):
        "Generate an ID for this commit that is useful to humans."
        if self.repo.streamed:
            return self.mark
        elif fullhash:
            return self.commit
        else:
            return self.commit[:7]
    def __repr__(self):
        r = "commit %s\n" % str(self)
        r += "committer %s %s\n" % (self.committer, self.commitdate)
        r += "author %s %s\n" % (self.author, self.authordate)
        r += "tree %s\n" % self.tree
        r += self.comment
        return r
    def parts(self):
        return (self.tree,
                self.author, self.authordate,
                self.committer, self.commitdate,
                self.comment)
    def difference(self, other):
        res = []
        # Alas, there's no better way to do this than with an ignores global
        if "author" not in ignores and self.author != other.author:
            res.append('author')
        if "authordate" not in ignores and \
               Commit.time_not_equal(self.authordate, other.authordate):
            res.append('authordate')
        if "committer" not in ignores and self.committer != other.committer:
            res.append('committer')
        if "commitdate" not in ignores \
               and Commit.time_not_equal(self.commitdate, other.commitdate):
            res.append('commitdate')
        if "comment" not in ignores and self.comment != other.comment:
            res.append('comment')
        if "tree" not in ignores and self.tree != other.tree:
            res.append('tree')
        return res
    def manifest(self):
        "Return a file manifest for this revision."
        filemap = {}
        with directory_context(self.repo.directory):
            do_or_die("git checkout --quiet %s" % self.commit)
            for path in capture_or_die("git ls-tree -r --full-name --name-only %s" % self.commit).split():
                if path:
                    if path.endswith(".gitignore") and "gitignore" in ignores:
                        continue
                    elif os.path.islink(path):
                        filemap[path] = os.readlink(path)
                    elif os.path.isfile(path):
                        with open(path) as fp:
                            filemap[path] = hashlib.md5(fp.read()).digest()
                    else:
                        sys.stderr.write("repodiffer: ignoring non-file non-symlink path %s\n" % path)
        return filemap
    def __hash__(self):
        return hash(self.parts())
    def __eq__(self, other):
        return not self.difference(other)

class Repository:
    "A repository, for comparison purposes."
    def __init__(self, sourcepath):
        self.path = sourcepath
        # Accept either a repository directory or an import stream
        if os.path.isdir(self.path):
            self.streamed = False
            self.directory = self.path
        elif os.path.isfile(self.path):
            self.streamed = True
            self.directory = tempfile.mkdtemp(prefix="rpd", suffix=str(os.getpid()))
            source = os.path.abspath(self.path)
            with directory_context(self.directory):
                do_or_die("git init --quiet; git fast-import --quiet --export-marks=.git/marks <%s" % source)
        else:
            raise Fatal("repodiffer: I don't know how to turn %s into a repo.")
        # Get a list of metadata and tree signatures for this repo
        with directory_context(self.directory):
            log = capture_or_die("git log --all --reverse --date-order --format=raw")
            # Ugh.  This split logic is ugly.  Is there a better way?
            self.signature = [Commit(self, "commit %s\n" % el) for el in log.split("\ncommit ")]
            if self.signature:
                self.signature.pop(0)
                self.signature[-1].text = self.signature[-1].text[:-1]
            if verbose >= DEBUG_LOWLEVEL:
                print "Commits in %s" % self.path
                for commit in self.signature:
                    print commit.commit
            self.mark_to_sha1 = {}
            self.sha1_to_mark = {}
            try:
                for line in open(".git/marks"):
                    (mark, sha1) = line.strip().split()
                    self.sha1_to_mark[sha1] = mark
                    self.mark_to_sha1[mark] = sha1
                for item in self.signature:
                    item.mark = self.sha1_to_mark[item.commit]
            except (IOError, OSError):
                pass
        # Also get a list of tags
        self.tagnames = set(capture_or_die("git tag -l").strip().split())
    def lookup(self, name):
        "Look up an object by name."
        for commit in self.signature:
            if commit.commit.startswith(name) or commit.mark == name:
                return commit
        else:
            return None
    def sort(self):
        "Sort by Committer-Date in case commits were generated in topo order."
        self.signature.sort(key=lambda c: c.timestamp())
    def __str__(self):
        return "<%s: %s>" % (self.path, self.signature)
    def __del__(self):
        if self.streamed:
            os.system("rm -fr " + self.directory)

def report_pair(a, b):
    global n_equal, n_insertions, n_deletions, n_replacements
    if a is None:
        n_insertions += 1
        print "inserted: %s" % b
        return
    if b is None:
        n_deletions += 1
        print "deleted: %s" % a
        return
    d = a.difference(b)
    left_only = right_only = different = None
    if 'tree' in d:
        a_files = a.manifest()
        b_files = b.manifest()
        a_fileset = set(a_files.keys())
        b_fileset = set(b_files.keys())
        left_only = a_fileset - b_fileset
        right_only = b_fileset - a_fileset
        different = [fn for fn in (a_fileset & b_fileset)
                     if a_files[fn] != b_files[fn]]
        if not (left_only or right_only or different):
            d.remove('tree')
    if d:
        n_replacements += 1
        print "changed: %s -> %s in %s." % (a, b, ",".join(d))
        if left_only:
            print "L only:"
            print "\n".join(list(left_only))
        if right_only:
            print "R only:"
            print "\n".join(list(right_only))
        if different:
            print "Differing files:"
            print "\n".join(list(different))
    else:
        n_equal += 1
        if showequal:
            print "equal: %s == %s" % (a, b)

def diff_single(single, alpha, beta):
    "Examine the difference between two specified commits."
    try:
        (a, b) = single.split("=")
    except ValueError:
        sys.stderr.write("repodiffer: need hashes or marks separated by =\n")
        sys.exit(1)
    ac = alpha.lookup(a)
    if ac is None:
        sys.stderr.write("repodiffer: no match for %s\n" % a)
        sys.exit(1)
    bc = beta.lookup(b)
    if bc is None:
        sys.stderr.write("repodiffer: no match for %s\n" % b)
        sys.exit(1)
    report_pair(ac, bc)

def diff_all(alpha, beta):
    "Walk through time-ordered commit pairs, finding differences."
    alpha.sort()
    beta.sort()
    i = 0
    tied = []
    duplicates =  []
    for a in alpha.signature:
        for b in beta.signature:
            if a.action_stamp() == b.action_stamp():
                # Throw out duplicates so all our pairs consist of
                # unique matches.
                if a.action_stamp() in duplicates:
                    continue
                elif a.matched or b.matched:
                    duplicates.append(a.action_stamp())
                    continue
                tied.append((a, b))
                a.matched = b
                b.matched = a 
    #print "repodiffer: %d pairs can be tied together of %d vs %d objects." \
    #      % (len(tied), len(alpha.signature), len(beta.signature))
    i = j = 0
    # Build the pairing table.
    pairs = []
    while i < len(alpha.signature) and j < len(beta.signature):
        a = alpha.signature[i]
        b = beta.signature[j]
        if (a, b) in tied:
            pairs.append((a, b))
            i += 1
            j += 1
        elif a.matched and b.matched:
            sys.stderr.write("repodiff: matches are out of order at %d:%d\n" \
                             % (i+1, j+1))
            sys.exit(1)
        if a.matched and not b.matched:
            pairs.append((None, b))
            j += 1
        if b.matched and not a.matched:
            pairs.append((a, None))
            i += 1
        if not a.matched and not b.matched:
            if a.timestamp() <= b.timestamp():
                pairs.append((a, None))
                pairs.append((None, b))
            else:
                pairs.append((a, None))
                pairs.append((None, b))
            i += 1
            j += 1
    # Report on the pair table
    for (a, b) in pairs:
        report_pair(a, b)
    if n_replacements or n_deletions or n_insertions:
        sys.stdout.write("statistics: %d equal, %d of %d inserted, %d of %d deleted.\n"
                         % (n_equal,
                            n_insertions,
                            len(beta.signature),
                            n_deletions,
                            len(alpha.signature)))
    if alpha.tagnames - beta.tagnames:
        sys.stdout.write("tags only in L: %s\n" % ",".join(list(alpha.tagnames - beta.tagnames)))
    if beta.tagnames - alpha.tagnames:
        sys.stdout.write("tags only in R: %s\n" % ",".join(list(beta.tagnames - alpha.tagnames)))

if __name__ == '__main__':
    if sys.hexversion < 0x02070000:
        sys.stderr.write("git-weave: requires Python 2.7 or later.")
        sys.exit(1)
    (options, arguments) = getopt.getopt(sys.argv[1:], "efi:sv:", ["showequal", "fullhash", "ignore=", "single=", "verbose="])
    alpha = None
    beta = None
    showequal = False
    fullhash = False
    ignores = ""
    single = None
    verbose = 0
    n_equal = n_insertions = n_deletions = n_replacements = 0 
    for (opt, val) in options:
        if opt == '-e' or opt == '--showequal':
            showequal = True
        elif opt == '-f' or opt == '--fullhash':
            fullhash = True
        elif opt == '-i' or opt == '--ignore':
            ignores = val
        elif opt == '-s' or opt == '--single':
            single = val
        elif opt == '-v' or opt == '--verbose':
            verbose = int(val)
    if len(arguments) < 2:
        sys.stderr.write("repodiffer: input and output directory or import-stream arguments are required.\n")
        sys.exit(1)
    else:
        (alpha, beta) = arguments[:2] 
    if not os.path.exists(alpha):
        sys.stderr.write("repodiffer: %s must exist.\n" % alpha)
        sys.exit(1)
    if not os.path.exists(beta):
        sys.stderr.write("repodiffer: %s must exist.\n" % beta)
        sys.exit(1)
    try:
        alpha = Repository(alpha)
        beta  = Repository(beta)
        if single:
            diff_single(single, alpha, beta)
        else:
            diff_all(alpha, beta)
    except Fatal, err:
        sys.stderr.write(err.msg + "\n")
        sys.exit(1)
    except KeyboardInterrupt:
        pass

# end
