<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Oct 31 2010</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <command>reposurgeon</command> is to enable risky
operations that VCSes (version-control systems) don't want to let you
do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing and splitting commits, (d) removing files and
subtrees from repo history, (e) merging or grafting two or more repos,
and (f) cutting a repo in two by cutting a parent-child link,
preserving the branch structure of both child repos.</para>

<para>The original motivation for <command>reposurgeon</command> was
to clean up artifacts created by repository conversions, and it has
some special-purpose commands for this use. With the addition of
extractors (see below) and the ability to read Subversion dumpfiles,
<command>reposurgeon</command> is a repository conversion tool in its
own right.  It was foreseen that the tool would also have applications
when code needs to be removed from repositories for legal or policy
reasons.</para>

<para>To keep <command>reposurgeon</command> simple and flexible, it
normally does not do its own repository reading and writing.  Instead, it
relies on being able to parse and emit the command streams created by
git-fast-export and read by git-fast-import.  This means that it can
be used on any version-control system that that has both fast-export
and fast-import utilities.  At time of writing this set includes git
itself, hg, and bzr. The git-import stream format also implicitly
defines a common language of primitive operations for
<command>reposurgeon</command> to speak.</para>

<para><command>reposurgeon</command> can also read - but not write -
dumpfiles produced by Subversion. It can thus be used to lift
Subversion repositories to any VCS that it has output support
for.</para>

<!--
<para>In order to deal with version-control systems that do not have
fast-export equivalents, <command>reposurgeon</command> can also host
extractor code that reads repositories directly.  For each
version-control system supported through an extractor,
<command>reposurgeon</command> uses a small amount of knowledge about
the system's command-line tools to (in effect) replay repository
history into an input stream internally. Repositories under systems
supported through extractors can be read by
<command>reposurgeon</command>, but not modified by it.  In
particular, <command>reposurgeon</command> can be used to move a
repostory history from any VCS supported by an extractor to any VCS
supported by a normal importer/exporter pair.</para>

A test extractor exists for git, but is normally disabled in favor of
the regular exporter. A Subversion extractor existed in an unreleased
version of <command>reposurgeon</command>, but due to extremely poor
performance it was discarded in favor of parsing dumpfiles.
-->

<para>At time of writing the following VCSes are supported through
both importers and exporters: git itself, hg, and bzr. Subversion
repositories can be imported but not exported.</para>
</refsect1>

<refsect1 id='warning'><title>SAFETY WARNINGS</title>

<para><command>reposurgeon</command> is a sharp enough tool to cut
you.  It takes care not to ever write a repository in an actually
inconsistent state, and will terminate with an error message rather
than proceed when its internal data structures are confused.  However,
there are lots of things you can do with it - like altering stored
commit timestamps to they no longer match the commit sequence - that
are likely to cause havoc after you're done.  Proceed with caution and
check your work.</para>

<para>Also note that, if your DVCS does the usual thing of making
commit IDs a cryptographic hash of content and parent links, editing a
publicly-accessible repository with this tool would be a bad idea. All
of the surgical operations in <command>reposurgeon</command> will
modify the hash chains, meaning others will become unable to pull
from or push to the repo.</para>

<para>Please also see the notes on system-specific issues under <xref
linkend='limitations'/>.</para>

</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an
interactive command interpreter or in batch mode to execute commands
given as arguments on the <command>reposurgeon</command> invocation
line. The only differences between these modes are (1) the interactive
one begins by turning on the 'verbose 1' option, and (2) in batch mode
all errors (including normally recoverable errors in selection-set
syntax) are fatal. Also, in interactive mode, Ctrl-P and Ctrl-N will
be available to scroll through your command history and tab completion
of command keywords is available.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo; to
avoid confusion with <command>reposurgeon</command> commands
we will refer to the stream commands as <emphasis>events</emphasis> in
this documentation.  These events are implicitly numbered from 1
upwards.  Most commands require specifying a selection of event
sequence numbers so <command>reposurgeon</command> will know
which events to modify or delete.</para>

<para>Commands to <command>reposurgeon</command> consist of a
command keyword, sometimes followed by a selection set, sometimes
followed by whitespace-separated arguments. It is often possible to
omit the selection-set argument and have it default to something
reasonable. When the command descriptions refer to a 'second' 
argument, it may actually be first after the keyword with the
selection set omitted.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
edit :15               ;; edit the object associated with mark :15

edit                   ;; edit all editable objects

list 29..71            ;; list summary index of events 20..71

list /regression/      ;; list all commits and tags with comments or
                       ;; committer headers or author headers containing 
                       ;; the string "regression"

delete =T &amp; 1..:97     ;; delete tags from event 1 to mark 97

inspect [Makefile]     ;; Inspect all commits with a file op touching Makefile

list (master)          ;; List commits on the 'master' branch
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the import stream format documentation for explanation
of the semantics of marks.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>tag and branch names</firstterm></term>
<listitem>

<para>The basename of a branch refers to its tip commit.  The name of
a tag is equivalent to its mark, and through that to a commit. Tag and
branch locations are bracketed with &lt; &gt; (angle brackets) to
distinguish them from command keywords. (But also see the discussion
of branch sets and &amp; a bit further on; also, in older versions
of this tool tag ad branch locations were prefixed with  '@' rather
than bracketed. The change fixed a parsing ambiguity)</para>
</listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading equal sign, followed by type
letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>H</entry>
        <entry align='center'>head (branch tip) commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>P</entry>
        <entry align='center'>Passthrough</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>branches</firstterm></term>
<listitem><para>A branch name (bracketed by parentheses) resolves to
the set of all commits on that branch, plus any tags pointed at them
and any associated branch resets.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>text search</firstterm></term>
<listitem><para>A text search expression is a Python regular expression 
surrounded by forward slashes (to embed a forward slash in it, use a
Python string escape such as \x2f).</para>

<para>A text search matches against the comment fields of commits and
annotated tags, or against their author/committer headers. 
It matches against the text of passthrough objects.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>paths</firstterm></term>
<listitem><para>A path name enclosed in [] resolves to the set of
all commits with a fileop that touches that file path - modifies
that change it, deletes that remove it, renames and copies that have 
it as a source or target.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Set expressions may be combined with the operators | and &amp;;
these are, respectively, set union and intersection. The | has lower
precendence than intersection, but you may use curly brackets '{' and
'}' to group expressions in case there is ambiguity.</para>

<para>Finally, any set operation may be followed by '?' to add the set
members' neighbors and referents.  This extends the set to include the
parents and children of all commits in the set, and the referents of
any tags and resets in the set. Each blob reference in the set is
replaced by all commits that refer to it.</para>

<refsect2 id='import-export'><title>IMPORT AND EXPORT</title>

<para><command>reposurgeon</command> can hold multiple repository
states in core.  Each has a name.  At any given time, one may be selected
for editing. Commands in this group import repositories, export them,
and manipulate the in-core list and the selection.</para>

<variablelist>
<varlistentry>
<term><command>read</command> 
        [<emphasis>infile</emphasis>]
</term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no arguments
does this in the current directory. If the argument is the name of a
plain file, it will be read in as a fast-import stream or Subversion
dumpfile. With an argument of <quote>-</quote>, this command reads a
fast-import stream or Subversion dumpfile from standard input (this
will be useful in filters constructed with command-line
arguments).</para>

<para>If the read location is a git repository and contains a 
<filename>.git/cvsauthors</filename> file (such as is left in in place
by <command>git cvsimport -A</command>) that file will be read in as
if it had been given to the <command>authors read</command>.</para>

<para>If the read location is a directory, and its repository
subdirectory has a file named <filename>fossils</filename>, that file
will be read as though passed to a <filename>fossil read</filename>
command.</para>

<para>The just-read-in repo is added to the list of loaded repositories and
becomes the current one, selected for surgery. If it was read from a
plain file and the file name ends with the extension <filename>.fi</filename>,
that is removed from the load list name.</para>

<para>Note: this command does not take a selection set.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>write</command>
        [<emphasis>selection-set</emphasis>]
        [<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Dump selected events as a fast-import stream representing the
edited repository; the default selection set is all events. The
optional second argument tells where to dump to; standard output if
argument is empty or '-' or a named file otherwise.  Fails if the
argument exists and is a directory or anything other than a plain
file.</para>

<para>Property extensions will be be omitted from the output if the
importer for the selected repo cannot digest them.</para>

<para>Note: to examine small groups of commits without the progress
meter, use <command>inspect</command>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>choose</command>
        [<emphasis>reponame</emphasis>]
</term>
<listitem>
<para>Choose a named repo on which to operate.  The name of a repo is
normally the basename of the directory or file it was loaded from, but
repos loaded from standard input are "unnamed".
<command>reposurgeon</command> will add a disambiguating
suffix if there have been multiple reads from the same source.</para>

<para>With no argument, lists the names of the currently stored
repositories and their load times.  The second column is '*' for the
currently selected repository, '-' for others.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>drop</command>
        [<emphasis>reponame</emphasis>]
</term>
<listitem>
<para>Drop a repo named by the argument from reposurgeon's list,
freeing the memory used for its metadata and deleting on-disk
blobs. With no argument, drops the currently chosen repo.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>rename</command>
        <emphasis>reponame</emphasis>
</term>
<listitem>
<para>Rename the currently chosen repo; requires an argument.  Won't
do it if there is already one by the new name.
</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='rebuild'><title>REBUILDS IN PLACE</title>

<para><command>reposurgeon</command> can rebuild an altered
repository in place.  Because of safety measures it takes to ensure
that no exiting repo is ever altered or clobbered, it has to be told
which untracked files should be saved and restored when the contents
of the new repository is checked out.</para>

<variablelist>
<varlistentry>
<term><command>rebuild</command>
        [<emphasis>directory</emphasis>]
</term>
<listitem>
<para> Rebuild a repository from the state held by
<command>reposurgeon</command>.  This command does not take a
selection-set argument.</para>

<para>The single argument, if present,
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import
stream), it defaults to that directory.  If the target directory is
nonempty its contents are backed up to a save directory.  Files and
directories on the repository's preserve list are copied back from the
backup directory after repo rebuild. The default preserve list
depends on the repository type, and can be displayed with the
<command>stats</command> command.</para>

<para>If <command>reposurgeon</command> has a nonempty fossil map,
it will be written to a file named <filename>fossils</filename> 
in the repository subdirectory as though by a 
<filename>fossil write</filename> command. (This will normally 
be the case for Subversion and CVS conversions.)</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>preserve</command> 
    [<emphasis>file...</emphasis>]
</term>
<listitem>
<para>Add (presumably untracked) files or directories to the repo's 
list of paths to be restored from the backup directory after a 
<command>rebuild</command>. Each argument, if any, is interpreted as a
pathname.  The current preserve list is displayed afterwards.</para>

<para>It is only necessary to use this command if your version-control system
lacks a command to list files under version control. Under systems with such
a command, all files that are neither beneath the repository dot directory
nor under reposurgeon temporary directories are preserved automatically.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>unpreserve</command>
    [<emphasis>file...</emphasis>]
</term>
<listitem><para>Remove (presumably untracked) files or directories to
the repo's list of paths to be restored from the backup directory
after a <command>rebuild</command>. Each argument, if any, is
interpreted as a pathname.  The current preserve list is displayed
afterwards.</para></listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='information'><title>INFORMATION AND REPORTS</title>

<para>Commands in this group report information about the selected
repository.</para>

<variablelist>
<varlistentry>
<term><command>list</command>
        [<emphasis>selection-set</emphasis>]
</term>
<listitem><para>This is the main command for identifying the events
you want to modify.  It lists commits in the selection set by event
sequence number with summary information. The first column is raw
event numbers, the second a timestamp in local time, and the third the
leading text of the comment.  If there is a second argument, or the
first is not recognized as a selection set, it will be taken as the
name of the file to report to; no argument, or one of '-'; writes to
standard output.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>tags</command>
        [<emphasis>selection-set</emphasis>...]
</term>
<listitem><para>
For each commit in the selection set with a branch member that
contains "/tags/", list the event and the branch member.  This
will list the lightweight tags in the selection set.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>stats</command>
        [<emphasis>repo-name</emphasis>...]
</term>
<listitem><para>
Report size statistics and import/export method information about
named repositories, or with no argument the currently chosen repository.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>inspect</command>
</term>
<listitem><para>
Dump a fast-import stream representing selected events to standard output.
Just like a write, except (1) the progress meter is disabled, (2) properties
are always dumped, and (3) there is an identifying header before each event
dump.
</para></listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='surgical'><title>SURGICAL OPERATIONS</title>

<para>These are the operations the rest of reposurgeon is designed
to support.</para>

<variablelist>
<varlistentry>
<term><command>delete</command>
        [<emphasis>selection-set</emphasis>]
        [<emphasis>policy...</emphasis>]
</term>
<listitem>
<para>Delete a selection set of commits. The default selection set for
this command is empty.</para>

<para>No <command>blob</command> event can be deleted directly with
this command; <command>blob</command> events are tied to associated
<command>commit</command> events and are discarded only when those
are.</para>

<para>Deleting a <command>tag</command>, <command>reset</command> or
<command>passthrough</command> event has no side effects.</para>

<para>The interesting use of this command is to delete commits.
Children of a deleted commit get it removed from their parent set and
its parents added.</para>

<para>Normally, when a commit is deleted, its file operation list (and
any associated blob references) gets either prepended to the beginning
of the operation list of each of the commit's children or appended to
the operation list of each of the commit's parents. The default is
to push forward. modifying children; but see the list of policy
modifiers below for how to change this.</para>

<para>Normally, any tag pointing to a deleted commit will also be
deleted.  But see the list of policy modifiers below for how to change
this.</para>

<para>Following all operation moves, every one of the altered file
operation lists is reduced to a shortest normalized form. The
normalized from detects various combinations of modification,
deletion, and renaming and simplifies the operation sequence as much
as it can without losing any information.</para>

<para>After canonicalization, a file op list may still end up containing
multiple M operations in the on the same file. Normally the tool utters a
warning when this occurs but does not try to resolve it.</para>

<para>The following modifiers change these policies:</para>

<variablelist>
<varlistentry>
<term>obliterate</term>
<listitem>
<para>simply discards all file ops associated with deleted commit(s).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>coalesce</term>
<listitem>
<para>Discard all M operations (and associated blobs) except the last.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>pushback</term>
<listitem>
<para>Append fileops to parents, rather than prepending to children.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>tagforward</term>
<listitem>
<para>With the "tagforward" modifier, any tag on the deleted commit is pushed
forward to the first child rather than being deleted.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>tagback</term>
<listitem>
<para>With the "tagback" modifier, any tag on the deleted commit is pushed
backward to the first parent than being deleted. </para>
</listitem>
</varlistentry>
<varlistentry>
<term>quiet</term>
<listitem>
<para>Suppresses warning messages about obliteration of commits with
non-delete fileops.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Under either of these policies, deleting a commit that has
children does not back out the changes made by that commit, as they
will still be present in the blobs attached to versions past the end
of the deletion set.  All a delete does when the commit has children
is lose the metadata information about when and by who those changes
were actually made; after the delete any such changes willbe
attributes to the first undeleted children of the deleted commits.  It
is expected that this command will be useful mainly for removing
commits mechanically generated by repository converters such as
<command>cvs2svn</command>.</para>

<para>Other policies which do more to attempt to back out content
changes may be added in future versions of this tool.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>cut</command>
        <emphasis>parent</emphasis>
</term>
<listitem>
<para>Attempt to partition a repo by cutting the parent-child link
between two specified commits (they must be adjacent). Does not take a
general selection-set argument.  It is only necessary to specify the
parent commit, unless it has multiple children in which case the child
commit must follow.</para>

<para>This operation may fail if the commit graph remains connected
through another path; the tool will detect this.</para>

<para>On success, the original repo will be dropped, and there will be no
repo still chosen, but two repos will appear in the in-core list. If
the repo was named 'foo', the cut segments will be named 'foo-early'
and 'foo-late'. Option and feature events at the beginning of the
early segnment will be duplicated onto the beginning of the late
one.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>expunge</command> 
        [<emphasis>selection-set</emphasis>]
        <emphasis>regexp...</emphasis>
</term>
<listitem>
<para>Expunge files from the selected portion of the repo history; the
default is the entire history.  The arguments to this command may be
paths or Python regular expressions matching paths.</para>

<para>All filemodify (M) operations and delete (D) operations
involving a matched file in the selected set of events are removed.
Renames are followed as the tool walks forward in the selection set;
each triggers a warning message. If a selected file is a copy (C)
target, the copy will be deleted and a warning message issued. If a
selected file is a copy source, the copy target will be added to the
list of paths to be deleted and a warning issued.</para>

<para>After file expunges have been performed, any commits with no
remaining file operations will be removed, and any tags pointing to
them.</para>

<para>The removed commits and blobs are not discarded. They are assembled
into a new repository named after the old one with the suffix "-expunges"
added.  This, this command can be used to carve a repository into sections
by file path matches.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>coalesce</command> 
        [<emphasis>selection-set</emphasis>]
        [<emphasis>timefuzz</emphasis>]
</term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques by deleting all but the
last commit, in order.</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated cliques of "*** empty log message ***"
commits from CVS lifts.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>split</command> 
        <emphasis>commit-location</emphasis>
        <command>at</command> 
        <emphasis>index</emphasis>
</term>
<listitem>
<para>Split a specified commit in two, the opposite of coalesce.  The
first argument is required to be a commit location; the separating
keyword 'at' must follow, then an integer 1-origin index of a file
operation within the commit.</para>

<para>The commit is copied and inserted into a new position in the
event sequence, immediately following itself; the duplicate becomes
the child of the original, and replaces it as parent of the original's
children. Commit metadata is duplicated; the mark of the new commit is
then changed, with 'bis' added as a suffix.</para>

<para>Finally, some file operations - starting at the one indexed by
the split argument - are moved forward from the original commit into
the new one.  Legal indices are 2-n, where n is the number of file
operations in the original commit.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>renumber</command>
</term>
<listitem>
<para>Renumber the marks in a repository, from :1 up to :&lt;n&gt;
where &lt;n&gt; is the count of the last mark. Just in case an importer
ever cares about mark ordering or gaps in the sequence.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>mailbox_out</command>
        [<emphasis>selection-set</emphasis>]
        [<emphasis>outfile</emphasis>]
</term>
<listitem>
<para>Emit a mailbox file of messages in RFC822 format representing
the contents of repository metadata. Takes a selection set; members of
the set other than commits, annotated tags, and passthroughs are
ignored (that is, presently, blobs and resets).  If there is a second
argument, or the first is not recognized as a selection set, it will
be taken as the name of the file to report to; no argument, or one of
'-'; writes to standard output.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>mailbox_in</command>
        [<emphasis>infile</emphasis>]
</term>
<listitem>
<para>Accept a mailbox file of messages in RFC822 format representing the
contents of the metadata in selected commits and annotated tags. Takes
no selection set.  If there is an argument it will be taken as the
name of a mailbox file to read from; no argument, or one of '-'; reads
from standard input.</para>

<para>Users should be aware that modifying an Event-Number field will change
which event the update from that message is applied to.  This is
unlikely to have good results.</para>

<para>If the Event-Number field is absent, the mailbox_in logic will
attempt to match the commit or tag first by Fossil-ID, then by a unique
committer ID and timestamp pair.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>edit</command>
        [<emphasis>selection-set</emphasis>]
</term>
<listitem>
<para>Report the selection set of events to a tempfile as mailbox_out does,
call an editor on it, and update from the result as mailbox_in does.
If you do not specify an editor name as second argument, it will be
taken from the $EDITOR variable in your environment.</para>

<para>Normally this command ignores blobs because mailbox_out does.
However, if you specify a selection set consisting of a single
blob, your editor will be called directly on the blob file.</para>

<para>The modifier 'multiline' will trim the selection set to commits that
are multiline and not in summary/blank-line/details form.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>timeoffset</command>
        offset 
        [<emphasis>timezone</emphasis>]
</term>
<listitem>
<para>Apply a time offset to all time/date stamps in the selected set.
An offset argument is required; it may be in the form [+-]ss,
[+-]mm:ss or [+-]hh:mm:ss.  The leading sign is required to distingush
it from a selection expression.</para>

<para>Optionally you may also specify another argument in the form [+-]hhmm, a
timeone literal to apply.  To apply a timezone without an offset, use
an offset literal of +0 or -0.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>unite</command>
        <emphasis>reponame</emphasis>...
</term>
<listitem>
<para>Unite repositories. Name any number of loaded repositories; they will
be united into one union repo and removed from the load list.  The
union repo will be selected.</para>

<para>Before merging, the repos will be sorted by date of first commit.  The
oldest will keep all its branch and tag names unchanged (this rule is
followed so there will always be a defined default branch).  All others
will have their branch and tag names suffixed with their load name.
Marks will be renumbered.</para>

<para>The name of the new repo will be the names of all parts concatenated,
separated by '+'. It will have no source directory or preferred system
type.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>graft</command>
        <emphasis>commit-id</emphasis>
        <emphasis>reponame</emphasis>.
</term>
<listitem>
<para>For when unite doesn't give you enough control.  The selection set
must be of size 1, identifying a single commit in the currently
selected repo.  A following argument must be a repository name.
Labels and branches in the named repo are prefixed with its name; then
it is grafted to the selected one. Its root becomes a child of the
specified commit.  Finally the named repo is removed from the load
list.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>paths</command>
        <command>perform</command>
        <command>force</command>.
</term>
<listitem>
<para>Takes a selection set. Without a modifier, list all paths
touched by fileops in the selection set (which defaults to the entire
repo). With the 'sub' modifier, take a second argument that is a
directory name and prepend it to every path. With the 'sup' modifier,
strip the first directory component from every path.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>merge</command>
</term>
<listitem>
<para>Merge branches. Takes a selection set argument, ignoring all but
the lowest (source) and highest (target) members; also, optional modifiers
'perform' and 'force'.</para>

<para>The simplest form of the command takes a singleton selection set,
interpreted as a source commit, and looks at each later commit as a
target to see if a clean merge is possible.  A clean merge is deemed
to be possible if every file in the source revision is present in the
target revision and the target-revision content of every file occuring
in the the source revision is either that of the source revision or was
modified by the target commit itself.</para>

<para>If the selection set has two members, the second (higher-numbered)
even is taken as the target commit and checked to see if a clean merge
is possible.  The output from the command says if it is, and if not
what missing and out-of-date files would make the merge unclean.</para>

<para>If the 'perform' modifier is given and a clean merge is available, it is
performed.  If both 'perform' and 'force' modifiers are given, the merge
is performed even if is not clean.</para>

<para>Warning: while clean merges will never alter the content of any
revision - they just change parent-child relationships - unclean merges
are not safe. Use with extreme caution.</para> 
</listitem>
</varlistentry>
<varlistentry>
<term><command>tag</command>
        <emphasis>tagname</emphasis>...
        <command>{move|rename|telete}</command>
        <command>[arg]</command>.
</term>
<listitem>
<para>Move, rename, or delete a tag.  First argument must be an
existing tag name; second argument must be one of the verbs 'move',
'rename', or 'delete'.</para>

<para>For a 'move', a third argument must be a singleton selection set. For
a 'rename', tha third argument may be any token. For a 'delete', no
third argument is required.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id="reference-lifting"><title>REFERENCE LIFTING</title>

<para>This group of commands is meant for fixing up references in commits
that are in the format of older version control systems.  The general
workflow is this: first, go over the comment history and change all
old-fashioned commit references into machine-parseable cookies.  Then,
automatically turn the machine-parseable cookie into action stamps.
The point of dividing the process this way is that the first part is
hard for a machine to get right, while the second part is prone to errors
when a human does it.</para>

<para>A Subversion cookie is a comment substring of the form
[[SVN:ddddd]] (example: [[SVN:2355]] with the revision read directly
via the Subversion exporter, deduced from git-svn metadata, or
matching a $Revision$ header embedded in blob data for the
filename.</para>

<para>A CVS cookie is a comment substring of the form
[[CVS:filename:revision]] (example: [[CVS:src/README:1.23]] with the
revision matching a CVS $Id$ or $Revision$ header embedded in blob
data for the filename.</para>

<para>A mark cookie is of the form [[:dddd]] and is simply a reference
to the specified mark. You may want to hand-patch this in when one of
previous forms is inconvenient.</para>

<para>An action stamp is an RFC3339 timestamp, followed by a '!',
followed by a committer email address; it refers to a commit without
being VCS-specific.  Thus, instead of "commit 304a53c2" or "r2355",
"2011-10-25T15:11:09Z!fred@foonly.com".</para>

<para>In order to support reference lifting,
<command>reposurgeon</command> internally builds a fossil-reference
map that associates revision identifiers in older version-control
systems with commits.  The contents of this map comes from three
places: (1) cvs2svn:rev properties if the repostory was read from a
Subversion dump stream, (2) $Id$ and $Revision$ headers in repository
files, and (3) the <filename>.git/cvs-revisions</filename> created by
<command>git cvsimport</command>.</para>

<para>The workflow for lifting possible references is this: first,
find possible CVS and Subversion references with the
<command>references</command>; then replace them with equivalent
cookies; then run <command>references lift</command> to turn the
cookies into action stamps (using the information in the
fossil-reference map) without having to do the lookup by hand.</para>

<variablelist>
<varlistentry>
<term><command>references</command>
          [<emphasis>selection-set</emphasis>]
          [<command>lift</command>]
</term>
<listitem>
<para>Search commit comments for strings that might be CVS- or
Subversion-style revision identifiers. This will be useful when you
want to replace them with equivalent cookies that can automatically be
translated into VCS-independent action stamps. With the modifier
'edit', edit the set where revision IDs are found.</para>

<para>With the modifier "lift", attempt to resolve Subversion and CVS
cookies in comments into action stamps using the fossil map. An action
stamp is a timestamp/email combination uniquely identifying the commit
associated with that blob, as described in <xref
linkend='style'/>.</para>

<para>It is not guaranteed that every such reference will be resolved,
or even that any at all will be. Normally all references in history
from a Subversion repository will resolve, but CVS references are less
likely to be resolvable.</para>

<para>Also, this command enables writing of the fossil map as 'fossil'
passthroughs when the repo is written to a stream file.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='artifact-removal'><title>ARTIFACT REMOVAL</title>

<para>Some commands automate fixing various kinds of artifacts
associated with repository conversions from order systems.</para>

<variablelist>
<varlistentry>
<term><command>authors</command>
          [<emphasis>selection-set</emphasis>]
          [<command>read</command>|<command>write</command>]
          [<command>filename</command>]
</term>
<listitem>
<para>Apply or dump author-map information for the specified selection
set, defaulting to all events.</para> 

<para>Lifts from CVS and Subversion may have only usernames local to
the repository host in committer and author IDs. DVCSes want email
addresses (net-wide identifiers) and complete names. To supply the map
from oune to the other, an authors file is expected to consist of
lines each beginning with a local user ID, followed by a '=' (possibly
surrounded by whitespace) followed by a full name and email address.</para>

<para>When an authors file is applied, email addresses in committer and author
metdata for which the local ID matches between &lt; and @ are replaced
according to the mapping (this handles git-svn lifts). Alternatively,
if the local ID is the entire address, this is also considered a match
(this handles what git-cvsimport and cvs2git do) </para>

<para>With the 'read' modifier, or no modifier and a filename
argument, apply author mapping data (no filename argument, read the
mapping from standard input).  May be useful if you are editing a repo
or dump created by cvs2git or by git-svn invoked without -A.</para>

<para>With no file argument, or with the 'write' modifier and a file
argument: write each unique committer, author, and tagger (no file
argument sends the report to standard output). This may be helpful as
a start on building an authors file.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='examining-tree-states'><title>EXAMINING TREE STATES</title>

<variablelist>
<varlistentry>
<term><command>checkout</command>
        <emphasis>directory</emphasis>
</term>
<listitem>
<para>Takes a selection set which must resolve to a single commit, and
a second argument. The second argument is interpreted as a directory
name.  The state of the code tree at that commit is materialized beneath
the directory.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>diff</command>
          [<emphasis>selection-set</emphasis>]
</term>
<listitem>
<para>Display the difference between commits. Takes a selection-set
argument which must resolve to exactly two commits.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='housekeeping'><title>HOUSEKEEPING</title>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><command>help</command>
</term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>shell</command>
</term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>prefer</command>
        [<emphasis>repotype</emphasis>]
</term>
<listitem>
<para>With no arguments, describe capabilities of all supported
systems. With an argument (which must be the name of a supported
system) this has two effects:</para>

<para>First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).</para>

<para>Secondly, if there is a selected repo, this will change its type.
This means that you do a write to a directory, it will build a repo of
the preferred type rather than its original type (if it had one).</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='instrumentation'><title>INSTRUMENTATION</title>

<para>A few commands have been implemented primarily for debugging and
regression-testing purposes, but may be useful in unusual
circumstances.</para>

<variablelist>
<varlistentry>
<term><command>index</command>
        [<emphasis>selection-set</emphasis>]
</term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>resolve</command>
        [<emphasis>selection-set</emphasis>]
</term>
<listitem><para>Does nothing but resolve a selection-set expression
and echo the resulting event-number set to standard
output. Implemented mainly for regression testing, but may be useful
for exploring the selection-set language.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>names</command>
</term>
<listitem><para>List the names of all known branches and tags.  Tells
you what things are legal within angle brackets and
parentheses.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>version</command>
</term>
<listitem><para>Report the version of <command>reposurgeon</command>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><command>verbose</command> 
        [<emphasis>n</emphasis>]
</term>
<listitem><para>'verbose 1' enables the progress meter and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>echo</command>
        [<emphasis>number</emphasis>]
</term>
<listitem><para>'echo 1' causes each 
<command>reposurgeon</command> command to be echoed to standard
output just before its output.  This can be useful in constructing regression
tests that are easily checked by eyeball.</para></listitem>
</varlistentry>
<varlistentry>
<term><command>script</command>
        <emphasis>filename</emphasis>
</term>
<listitem><para>Takes a filename argument. Reads each line from the file 
and executes it as a command.</para>

<para>Within scripts (and only within scripts) a command that takes an input 
filename argument can instead take literal following data in the syntax of a 
shell here-document. That is: if the filename is replaced by "&lt;&lt;EOF",
all following lines in the script up to a terminating line consisting
only of "EOF" will be read, placed in a temporary file, and that file
fed to the command and afterwards deleted. EOF may be replaced by
any string.</para> 
</listitem>
</varlistentry>
<varlistentry>
<term><command>history</command>
</term>
<listitem>
<para>List the commands you have entered this session.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>fossils</command>
          [<command>read</command>|<command>write</command>]
          [<command>filename</command>]
</term>
<listitem>
<para>Apply or list fossil-reference information. Does not take a
selection set.</para>

<para> A fossil-reference file maps reference cookies to (committer,
commit-date) pairs; these in turn (should) uniquely identify a commit.
The format is three whitespace-separated fields: the cookie, an RFC3339
timestamp, and a committer email ID.</para>

<para>It should not normally be necessary to use this command.  The
fossil map is automatically preserved through repository reads and
rebuilds, being stored in the file <filename>fossils</filename> under
the repository subdirectory..</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>set </command>
          [<command>option</command>]
</term>
<listitem>
<para>Turn on an option flag.  With no arguments, list all options</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>clear </command>
          [<command>option</command>]
</term>
<listitem>
<para>Turn off an option flag.  With no arguments, list all options</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>profile</command> 
</term>
<listitem>
<para>Enable profiling. Must be one of the initial command-line arguments, and
gathers statistics only on code executed via '-'.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>
</refsect1>

<refsect1 id='subversion'><title>WORKING WITH SUBVERSION</title>

<para><application>reposurgeon</application> can read Subversion
dumpfiles or dump from a Subversion repository (not a checkout
directory). You can usually use use svnsync to make a local mirror of
the repository you are interested in. <application>reposurgeon</application>
cannot write a Subversion repository, but history read from one can be
exported to any VCS for which <application>reposurgeon</application> has
an importer specified.</para>

<para>Here are the rules used for mapping subdirectories in a 
Subversion repository to branches:</para>

<orderedlist>
<listitem><para>A repository is considered "flat" if it has no /trunk
directory.  All commits in a flat repository are assigned to branch master.
In this case, we're done; all the other rules apply to non-flat
repos.</para></listitem>

<listitem><para>/trunk always becomes the master branch.</para></listitem>

<listitem><para>If there are /tags and /branches directories, each
subdirectory of these is considered a potential branch.  All top-level
directories other than /trunk, /tags, and /branches are also considered
potential branches.</para></listitem>

<listitem><para>Each potential branch is checked to see if it has
commits on it after the initial creation or copy.  If there are such
commits, it becomes a branch.  If not, it becomes a tag in order to
preserve the commit metadata.  (In all cases, the name of the tag or
branch is the basename of the directory.)</para></listitem>

<listitem><para>Files in the top-level directory are assigned to a
synthetic branch named 'root'.</para></listitem>
</orderedlist>

<para>If you give the command <command>set svn_nobranch</command> before
reading a Subversion repository, branch analysis is skipped and the
repository is left as a linear sequence of commits on refs/heads/master.
This may be useful if your repository configuration an unusual and you
need to do your own branch surgery.</para>

<para>Each commit that only creates or deletes directories (in
particular, copy commits for tags and branches, and commits that only
change properties) will be transformed into a tag named after the
branch, containing the date/author/comment metadata from the
commit. While this produces a desirable result for tags, non-tag
branches (including trunk) will also get root tags this way. This
apparent misfeature has been accepted so that
<application>reposurgeon</application> will never destroy
human-generated metadata that might have value; it is left up to the
user to manually remove unwanted tags.</para>

<para>Subversion branch deletions are turned into deletealls, clearing the 
fileset of the import-stream branch.  When a branch 
finishes with a deleteall at its tip, the deleteall is transformed
into a tag. This rule cleans up after aborted branch renames.</para>

<para>Occasionally (and usually by mistake) a branchy Subversion
repository will contain revision that touch multiple branches. These
are handled by partitioning them into multiple import-stream commits,
one on each affected branch. The Fossil-ID of such a split commit
will have a pseudo-decimal part - for examble, if Subversion revision 2317
touches three branches, the three generated commits will have IDs
2317.1, 2317.2, and 2317.3. In addition, the second and all subsequent
commits will have their timestamps incremented by a second each in
order to make the committer/timstamp pairs distinguishable.</para>

<para>The svn:executable and svn:special properties are translated
into permission settings in the input stream; svn:executable becomes
100755 and svn:special becomes 120000 (indicating a symlink; the blob 
contents will be the path to which the symlink should resolve).</para>

<para>Any cvs2svn:rev properties generated by
<application>cvs2svn</application> are incorporated into the internal map
used for reference-lifting, then discarded.</para>

<para>Per-directory svn:ignore properties become .gitignore files; if
you're somehow managed to have an actual .gitignore file in a
Subversion directory with an svn:ignore property, the file will get
stepped on.</para>

<para>All other Subversion properties are discarded. (This may change in a 
future release.) The property for which this is most likely to cause
semantic problems is svn:eol-style. However, since property-change-only
commits get turned into annotated tags, the translated tags will retain
information about setting changes.</para>

<para>The subsecond resolution on Subversion commit dates is discarded;
Git wants integer timestamps only.</para>

<para>Normally, Subversion local usernames are mapped in the style of
git cvs-import; thus user "foo" becomes "foo &lt;foo&gt;", which is
sufficient to pacify git and other systems that require email
addresses.  With the option "use-uuid", udernames are mapped in the
git-svn style, with the repository's UUID used as a fake domain in the
email address. Both forms can be remapped to real address using
the <command>authors read</command> command.</para>

<para>Reading a Subversion stream enables writing of the fossil map as
'fossil' passthroughs when the repo is written to a stream
file.</para>
</refsect1>

<refsect1 id='style'><title>TRANSLATION STYLE</title>

<para>After converting a CVS or SVN repository, check for and remove
$-cookies in the head revision(s) of the files. The full Subversion
set is $Date:, $Revision:, $Author:, $HeadURL and $Id:. CVS uses
$Author:, $Date:, $Header:, $Id:, $Log:, $Revision:, also (rarely)
$Locker:, $Name:, $RCSfile:, $Source:, and $State:.</para>

<para>When you need to specify a commit, use the action-stamp format
that <command>references lift</command> generates when it can resolve
an SVN or CVS reference in a comment. It is best that you
<emphasis>not vary from this format</emphasis>, even in trivial ways
like omitting the 'Z' or changing the 'T' or '!'. Making action stamps
uniform and machine-parseable will have good consequences for future
repository-browsing tools.</para>

<para>Sometimes, in converting a repository, you may need to insert an
explanatory comment - for example, if metadata has been garbled or
missing and you need to point to that fact. It's helpful for
repository-browsing tools if there is a uniform syntax for this that
is highly unlikely to show up in repository comments.  I recommend
enclosing translation notes in [[ ]].  This has the advantage of being
visually similar to the [ ] traditionally used for editorial comments
in text.</para>

<para>It is good practice to include, in the comment for the root
commit of the repository, a note dating and attributing the conversion
work and explaining these conventions.  Example:</para>

<blockquote>
<para>[[This repository was converted from Subversion to git on 2011-10-24
by Eric S. Raymond &lt;esr@thyrsus.com&gt;.  Here and elsewhere, conversion
notes are enclosed in double square brackets. Junk commits generated
by cvs2svn have been removed, commit references have been mapped into
a uniform VCS-independent syntax, and some comments edited into
summary-plus-continuation form.]]</para>
</blockquote>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: In DVCses that use commit hashes, editing with
<command>reposurgeon</command> never changes the hash of a commit
object unless (a) you edit the commit, or (b) it is a descendant of an
edited commit in a VCS that includes parent hashes in the input of a
child object's hash (git and hg both do this).</para>

<para>Guarantee: <command>reposurgeon</command> only requires
main memory proportional to the size of a repository's metadata
history, not its entire content history. Blobs are stored on disk.</para>

<para>Guarantee: <command>reposurgeon</command> never modifies
the contents of a repository it reads, nor deletes any repository. The
results of surgery are always expressed in a new repository.</para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <command>reposurgeon</command> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <command>reposurgeon</command> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Guarantee: <command>reposurgeon</command> handles the bzr 
commit-properties extension, correctly passing through property
items including those with embedded newlines. (Such properties
are also editable in the mailbox format.)</para>

<para>Limitation: Because <command>reposurgeon</command>
relies on other programs to generate and interpret the fast-import command
stream, it is subject to bugs in those programs.</para>

<para>Limitation: bzr suffers from deep confusion over whether its
unit of work is a repository or a floating branch that might have been
cloned from a repo or created from scratch, and might or might not be
destined to be merged to a repo one day. Its exporter only works on
branches, but its importer creates repos.  Thus, a rebuild operation
will produce a subdirectory structure that differs from what you
expect.  Look for your content under the subdirectory 'trunk'.</para>

<para>Limitation: under git, signed tags are imported verbatim. However, any
operation that modifies any commit upstream of the target of the 
tag will invalidate it.</para>

<para>Limitation: Stock git (at least as of version 1.7.3.2) will choke on
property extension commands. Accordingly, <command>reposurgeon</command> 
omits them when rebuilding a repo with git type.</para>

<!-- was: https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools -->
<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<command>reposurgeon</command>. See the <ulink
url="https://git.wiki.kernel.org/articles/i/n/t/Interfaces,_frontends,_and_tools.html">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='requirements'><title>REQUIREMENTS</title>

<para><command>reposurgeon</command> relies on importers and exporters 
associated with the VCSes it supports.</para>

<variablelist>
<varlistentry>
<term>git</term>
<listitem><para>Core git supports both export and import.</para></listitem>
</varlistentry>
<varlistentry>
<term>bzr</term>
<listitem><para>Requires bzr plus the bzr-fast-import plugin.</para></listitem>
</varlistentry>
<varlistentry>
<term>hg</term>
<listitem>
<para>Requires core hg, the hg-fastimport plugin, and the third-party 
hg-fast-export.py script.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>svn</term>
<listitem>
<para>Read only, via <command>svnadmin dump</command>.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect1>

<refsect1 id='canonicalization'><title>CANONICALIZATION RULES</title>

<para>It is expected that <command>reposurgeon</command> will
be extended with more deletion policies. Policy authors may 
need to know more about how a commit's file operation sequence
is reduced to normal form after operations from deleted commits
are prepended to it.</para>

<para>Recall that each commit has a list of file operations, each a M
(modify), D (delete), R (rename), C (copy), or 'deleteall' (delete all
files). Only M operations have associated blobs.  Normally there is
only one M operation per individual file in a commit's operation
list.</para>

<para>To understand how the reduction process works, it's enough to
understand the case where all the operation in the list are working
on the same file. Sublists of operations referring to different
files don't affect each other and reducing them can be thought
of as separate operations.  Also, a "deleteall" acts as a D for
everything and cancels all operations before it in the list. </para>

<para>The reduction process walks through the list from the beginning
looking for adjacent pairs of operations it can compose.  The following table
describes all possible cases and all but one of the reductions.</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <tbody>
      <row>
        <entry align='center'>M + D &rarr; D</entry>
	<entry align='left'><para>If a file is modified
	then deleted, the result is as though it had been
	deleted. If the M was the only modify for the file, it's 
	removed too.</para></entry>
      </row>
      <row>
        <entry align='center'>M a + R a b &rarr; R a b + M b</entry>
        <entry align='left'><para>The purpose of this transformation is 
	to push renames towards the beginning of the list,
	where they may become adjacent to another R or C they can 
	be composed with. If the M is the only modify operation for
	this file, the rename is dropped.</para></entry>
      </row>
      <row>
        <entry align='center'>M a + C a b</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>M b + R a b &rarr; nothing</entry>
	<entry align='left'><para>Should be impossible, and may
	indicate repository corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>M b + C a b &rarr; nothing</entry>
	<entry align='left'><para>The copy undoes the
	modification.</para></entry>
      </row>
      <row>
        <entry align='center'>D + M &rarr; M</entry>
	<entry align='left'><para>If a file is deleted and modified,
	the result is as though the deletion had not taken place
	(because M operations store entire files, not
	deltas).</para></entry>
      </row>
      <row>
        <entry align='center'>D + {D|R|C}</entry>
	<entry align='left'><para>These cases should be impossible
	and would suggest the repository has been corrupted.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + D a</entry>
	<entry align='left'><para>Should never happen, and is 
	another case that would suggest repository corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + D b &rarr; nothing</entry>
	<entry align='left'><para>The delete removes the just-renamed file.</para></entry>
      </row>
      <row>
        <entry align='center'>{R|C} + M</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + R b c &rarr; R a c</entry>
	<entry align='left'><para>The b terms have to match for these
	operations to have made sense when they lived in separate
	commits; if they don't, it indicates repository
	corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + C b c</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + D a &rarr; R a b</entry>
	<entry align='left'><para>Copy followed by delete of the source is a rename.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + D b &rarr; nothing</entry>
	<entry align='left'><para>This delete undoes the copy.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + R a c</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + R b c &rarr; C a c</entry>
	<entry align='left'><para>Copy followed by a rename of the
	target reduces to single copy</para></entry>
      </row>
      <row>
        <entry align='center'>C + C</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</refsect1>

<refsect1 id='recovery'><title>CRASH RECOVERY</title>

<para>This section will become relevant only if 
<command>reposurgeon</command> or something underneath it in the
software and hardware stack crashes while in the middle of writing out 
a repository, in particular if the target directory of the rebuild is
your current directory.</para>

<para>The tool has two conflicting objectives. On the one hand, we
never want to risk clobbering a pre-existing repo.  On the other hand,
we want to be able to run this tool in a directory with a repo and
modify it in place.</para>

<para>We resolve this dilemma by playing a game of three-directory monte.</para>

<procedure>
<step><para>First, we build the repo in a freshly-created staging
directory.  if your target directory is named
<filename>/path/to/foo</filename>, the staging directory will be a
peer named <filename>/path/to/foo-stageNNNN</filename>, where NNNN is
a cookie derived from <command>reposurgeon</command>'s process
ID.</para></step>

<step>
<para>We then make an empty backup directory.  This directory will
be named <filename>/path/to/foo.~N~</filename>, where N is incremented
so as not to conflict with any existing backup drectories.  
<command>reposurgeon</command> never, under any circumstances,
ever deletes a backup directory.</para>

<para>So far, all operations are safe; the worst that can happen up to
this point if the process gets interrupted is that the staging and
backup directories get left behind.</para>
</step>

<step><para>The critical region begins. We first move everything in the
target directory to the backup directory.</para></step>

<step><para>Then we move everything in the staging directory to the
target.</para></step>

<step><para>We finish off by restoring untracked files in the target
directory from the backup directory. That ends the critical
region.</para></step>
</procedure>

<para>During the critical region, all signals that can be ignored are
ignored.</para>
</refsect1>

<refsect1 id='returns'><title>ERROR RETURNS</title>
<para>Returns 1 on fatal error, 0 otherwise.  In batch mode all errors
are fatal.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@thyrsus.com</email>; project page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>.</para>
</refsect1>
</refentry>
