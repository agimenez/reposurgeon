<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC 
   "-//OASIS//DTD DocBook XML V4.1.2//EN"
   "docbook/docbookx.dtd">
<refentry id='reposurgeon.1'>
<refmeta>
<refentrytitle>reposurgeon</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='date'>Oct 31 2010</refmiscinfo>
<refmiscinfo class='productname'>reposurgeon</refmiscinfo>
<refmiscinfo class='source'>reposurgeon</refmiscinfo>
<refmiscinfo class='manual'>Development Tools</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>reposurgeon</refname>
<refpurpose>surgical operations on repositories</refpurpose>
</refnamediv>
<refsynopsisdiv id='synopsis'>

<cmdsynopsis>
  <command>reposurgeon</command>
  <arg choice='opt' rep='repeat'><replaceable>command</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsect1 id='description'><title>DESCRIPTION</title>

<para>The purpose of <command>reposurgeon</command> is to
enable risky operations that version-control systems don't want to let
you do, such as (a) editing past comments and metadata, (b) excising
commits, (c) coalescing commits, (d) removing files and subtrees from
repo history, and (e) splitting a repo in two by cutting a parent-child
link, preserving the branch structure of both child repos.</para>

<para>The original motivation for
<command>reposurgeon</command> was to clean up artifacts
created by repository conversions. It was foreseen that the tool would
also have applications when code needs to be removed from repositories
for legal or policy reasons.</para>

<warning><para><command>reposurgeon</command> is a sharp
enough tool to cut you.  It takes care not to ever write a repository
in an actually inconsistent state, and will terminate with an error
rather than proceed when its internal data structures are confused.
However, there are lots of things you can do with it - like altering
stored commit timestamps to they no longer match the commit sequence
- that are likely to cause havoc after you're done.  Proceed with
caution and check your work.</para></warning>

<para>To keep <command>reposurgeon</command> simple and
flexible, it does not do its own repository reading and writing.
Instead, it relies on being able to parse and emit the repo-command
streams created by git-fast-export and read by git-fast-import.  This
means that it can be used on any version-control system that that has
both fast-export and fast-import utilities.  This set includes git
itself, hg, and bzr. The git-import stream format also implicitly
defines a common language of primitive operations for
<command>reposurgeon</command> to speak.</para>
</refsect1>

<refsect1 id='options'><title>OPERATION</title>
<para>The program can be run in one of two modes, either as an
interactive command interpreter or to execute commands given as
arguments on the <command>reposurgeon</command> invocation line. The
only difference between these modes is that the interactive one begins
by turning on the 'verbose 1' option. Also, in interactive mode,
Ctrl-P and Ctrl-N will be available to scroll through your command
history.</para>

<para>A git-fast-import stream consists of a sequence of commands
which must be executed in the specified sequence to build the repo; to
avoid confusion with <command>reposurgeon</command> commands
we will refer to the stream commands as <emphasis>events</emphasis> in
this documentation.  These events are implicitly numbered from 1
upwards.  Most commands require specifying a selection of event
sequence numbers so <command>reposurgeon</command> will know
which events to modify or delete.</para>

<para>Commands to <command>reposurgeon</command> consist of a
command keyword, sometimes followed by a selection set, sometimes
followed by whitespace-separated arguments. It is often possible to
omit the selection-set argument and have it default to something
reasonable. When the command descriptions refer to a 'second' 
argument, it may actually be first after the keyword with the
selection set omitted.</para>

<para>Here are some motivating examples.  The commands will be
explained in more detail after the description of selection
syntax.</para>

<programlisting>
edit :15               ;; edit the object associated with mark :15

edit                   ;; edit all editable objects

list 29..71            ;; list summary index of events 20..71

list /regression/      ;; list all commits and tags with comments containing 
                       ;; the string "regression"

delete =t &amp; 1..:97     ;; delete tags from event 1 to mark 15

list *master           ;; List commits on the 'master' branch
</programlisting>

<para>The selection-set specification syntax is an expression-oriented 
minilanguage.  The most basic term in this language is a 
<firstterm>location</firstterm>. The following sorts of primitive locations
are supported:</para>

<variablelist>
<varlistentry>
<term><firstterm>event numbers</firstterm></term>
<listitem><para>A plain numeric literal is interpreted as a 1-origin
event-sequence number.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>marks</firstterm></term>
<listitem><para>A numeric literal preceded by a colon is interpreted
as a mark; see the import stream format documentation for explanation
of the semantics of marks.</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>tag and branch names</firstterm></term>
<listitem>

<para>The basename of a branch refers to its tip commit.  The name of
a tag is equivalent to its mark, and through that to a commit. Tag and
branch locations are led with @ to distinguish them from command
keywords. (But also see the discussion of branch sets and &amp; a bit 
further on)</para>
</listitem>
</varlistentry>
</variablelist>

<para>These may be grouped into sets in the following ways:</para>

<variablelist>
<varlistentry>
<term><firstterm>ranges</firstterm></term>
<listitem><para>A range is two locations separated by "..", and is
the set of events begining at the left-hand location and ending at the
right-hand location (inclusive).</para></listitem>
</varlistentry>
<varlistentry>
<term><firstterm>lists</firstterm></term>
<listitem><para>Comma-separated lists of locations and ranges are 
accepted, with the obvious meaning.</para></listitem>
</varlistentry>
</variablelist>

<para>There are some other ways to construct event sets:</para>

<variablelist>
<varlistentry>
<term><firstterm>visibility sets</firstterm></term>
<listitem>
<para>A visibility set is an expression specifying a set of event
types. It will consist of a leading equal sign, followed by type
letters. These are the type letters:</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='3' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <colspec colname='c3'/>
    <tbody>
      <row>
        <entry align='center'>B</entry>
        <entry align='center'>blobs</entry>
	<entry><para>Most default selection sets exclude blobs; they
	have to be manipulated through the commits they are attached
	to.</para></entry>
      </row>
      <row>
        <entry align='center'>C</entry>
        <entry align='center'>commits</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>T</entry>
        <entry align='center'>tags</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>R</entry>
        <entry align='center'>resets</entry>
	<entry><para>&nbsp;</para></entry>
      </row>
      <row>
        <entry align='center'>P</entry>
        <entry align='center'>Passthrough</entry>
	<entry><para>All event types types simply passed through,
	including comments, <command>progress</command> commands, 
        and <command>checkpoint</command> commands.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</listitem>
</varlistentry>
<varlistentry>
<term><firstterm>branches</firstterm></term>
<listitem><para>A branch name (preceded by *) resolves to the set of
all commits on that branch, plus any tags pointed at them and any
associated branch resets.</para>
</listitem>
<varlistentry>
<term><firstterm>text search</firstterm></term>
<listitem><para>A text search expression is a Python regular expression 
surrounded by forward slashes (to embed a forward slash in it, use a
Python string escape such as \x2f).</para>

<para>A text search matches against the comment fields of commits and
annotated tags; it also matches against the text of passthrough
objects.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Set expressions may be combined with the operators | and &amp;;
these are, respectively, set union and intersection. The | has lower
precendence than intersection, but you may use curly brackets '{' and
'}' to group expressions in case there is ambiguity.</para>

<refsect2 id='import-export'><title>IMPORT AND EXPORT</title>

<para><command>reposurgeon</command> can hold multiple repository
states in core.  Each has a name.  At any given time, one may be selected
for editing. Commands in this group import repositories, export them,
and manipulate the in-core list and the selection.</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis>
    <command>read</command> 
        <arg choice='opt'><replaceable>infile</replaceable></arg>
</cmdsynopsis></term>
<listitem><para>With a directory-name argument, this command attempts
to read in the contents of a repository in any supported
version-control system under that directory; read with no
arguments does this in the current directory. If the argument is the
name of a plain file, it will be read in as a fast-import stream. With
an argument of <quote>-</quote>, this command reads a fast-import
stream from standard input (this will be useful in filters constructed
with command-line arguments).</para>

<para>The just-read-in repo becomes the current one, selected for
surgery.</para>

<para>Note: this command does not take a selection set.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>write</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
        <arg choice='opt'><replaceable>outfile</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Dump selected events as a fast-import stream representing the
edited repository; the default selection set is all events. The
optional second argument tells where to dump to; standard output if
argument is empty or '-' or a named file otherwise.  Fails if the
argument exists and is a directory or anything other than a plain
file.</para>

<para>Note: a <command>write</command> with a small selection set can 
be a useful way to examine small groups of commits.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>choose</command>
        <arg choice='opt'><replaceable>reponame</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Choose a named repo on which to operate.  The name of a repo is
normally the basename of the directory or file it was loaded from, but
repos loaded from standard input are "unnamed".
<command>reposurgeon</command> will add a disambiguating
suffix if there have been multiple reads from the same source.</para>

<para>With no argument, lists the names of the currently stored
repositories and their load times.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>drop</command>
        <arg choice='opt'><replaceable>reponame</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Drop a repo named by the argument from reposurgeon's list,
freeing the memory used for its metadata and deleting on-disk
blobs. With no argument, drops the currently chosen repo.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>rename</command>
        <arg choice='plain'><replaceable>reponame</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Rename the currently chosen repo; requires an argument.  Won't
do it if there is already one by the new name.
</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='rebuild'><title>REBUILDS IN PLACE</title>

<para><command>reposurgeon</command> can rebuild an altered
repository in place.  Because of safety measures it takes to ensure
that no exiting repo is ever altered or clobbered, it has to be told
which untracked files should be saved and restored when the contents
of the new repository is checked out.</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis>
    <command>rebuild</command>
        <arg choice='opt'><replaceable>directory</replaceable></arg>
</cmdsynopsis></term>
<listitem><para> Rebuild a repository from the state held by
<command>reposurgeon</command>.  This command does not take a
selection-set argument.  The single argument, if present argument
specifies the target directory in which to do the rebuild; if the
repository read was from a repo directory (and not a git-import
stream), it defaults to that directory.  If the target directory is
nonempty its contents are backed up to a save directory.  Files and
directories on the repository's restore list are copied back from the
backup directory.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>restore</command> 
    <arg choice='opt' rep='repeat'><replaceable>file</replaceable></arg>
</cmdsynopsis></term>
<listitem><para>Add (presumably untracked) files or directories to the repo's 
list of paths to be restored from the backup directory after a 
<command>rebuild</command>. Each argument, if any, is interpreted as a
pathname.  The current restore list is displayed afterwards.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>unrestore</command>
    <arg choice='opt' rep='repeat'><replaceable>file</replaceable></arg>
</cmdsynopsis></term>
<listitem><para>Remove (presumably untracked) files or directories to
the repo's list of paths to be restored from the backup directory
after a <command>rebuild</command>. Each argument, if any, is
interpreted as a pathname.  The current restore list is displayed
afterwards.</para></listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='information'><title>INFORMATION AND REPORTS</title>

<para>Commands in this group report information about the selected
repository.</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis>
    <command>list</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
</cmdsynopsis></term>
<listitem><para>This is the main command for identifying the events
you want to modify.  It lists commits in the selection set by event
sequence number with summary information. The first column is raw
event numbers, the second a timestamp in local time, and the third the
leading text of the comment.  If there is a second argument, or the
first is not recognized as a selection set, it will be taken as the
name of the file to report to; no argument, or one of '-'; writes to
standard output.  </para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>stats</command></cmdsynopsis></term>
<listitem><para>
Report size statistics and import/export method information about
the currently chosen repository.
</para></listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='surgical'><title>SURGICAL OPERATIONS</title>

<para>These are the operations the rest of reposurgeon is designed
to support.</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis>
    <command>delete</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
        <arg choice='opt'><replaceable>policy</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Delete a selection set of commits. The default selection set for
this command is empty.</para>

<para>No <command>blob</command> event can be deleted directly with
this command; <command>blob</command> events are tied to associated
<command>commit</command> or <command>tag</command> events and are
discarded only when those are.</para>

<para>Deleting a <command>tag</command>, <command>reset</command> or
<command>passthrough</command> event has no side effects.</para>

<para>The interesting use of this command is to delete commits.
Children of a deleted commit get it removed from their parent set and
its parents added.  Any tag pointing to a deleted commit will also
be deleted (note that git lightweight tags are implemented as 
branches and will thus escape this fate).</para>

<para>When a commit is deleted, its file operation list (and any
associated blob references) gets pushed forward onto the beginning of
the operation list of each of the commit's children. Following all
pushes, every one of the altered file operation lists is reduced to a
shortest normalized form. The normalized from detects various
combinations of modification, deletion, and renaming and simplifies
the operation sequence as much as it can without losing any
information.</para>

<para>After canonicalization, a file op list may still end up containing
multiple M operations in the on the same file.  Two policies are
presently available for dealing with this:</para>

<variablelist>
<varlistentry>
<term>complain</term>
<listitem>
<para>Complain about them, but do nothing. This is the default.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>coalesce</term>
<listitem>
<para>Discard all M operations (and associated blobs) except the last.</para>
</listitem>
</varlistentry>
</variablelist>

<para>Under either of these policies, deleting a commit that has
children does not back out the changes made by that commit, as they
will still be present in the blobs attached to versions past the end
of the deletion set.  All a delete does when the commit has children
is lose the metadata information about when and by who those changes
were actually made; after the delete any such changes will.  It is
expected that this command will be useful mainly for removing commits
mechanically generated by repository converters such as
<command>cvs2svn</command>.</para>

<para>Other policies which do more to attempt to back out content
changes may be added in future versions of this tool.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>split</command>
        <arg choice='plain'><replaceable>parent</replaceable></arg></cmdsynopsis></term>
<listitem>
<para>Attempt to partition a repo by cutting the parent-child link
between two specified commits (they must be adjacent). Does not take a
general selection-set argument.  It is only necessary to specify the
parent commit, unless it has multiple children in which case the child
commit must follow.</para>

<para>This operation may fail if the commit graph remains connected
through another path; the tool will detect this.</para>

<para>On success, original repo will be dropped, and there will be no
repo still chosen, but two repos will appear in the in-core list. If
the repo was named 'foo', the cut segments will be named 'foo-early'
and 'foo-late'.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>expunge</command> 
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
        <arg choice='plain' rep='repeat'><replaceable>regexp</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>NOT YET IMPLEMENTED</para>

<para>Expunge files from the selected portion of the repo history; the
default is the entire history.  The arguments to this command may be
paths or Python regular expressions matching paths.</para>

<para>All filemodify (M) operations and delete (D) operations
involving a matched file in the selected set of events are removed.
Renames are followed as the tool walks forward in the selection set;
each triggers a warning message. If a selected file is a copy (C)
target, the copy will be deleted and a wearning message issued. If a
selected file is a copy source, the copy target will be added to the
list of paths to be deleted and a warning issued.</para>

<para>After file expunges have been performed, any commits with no
remaining file operations will be deleted, and any tags pointing to
them.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>coalesce</command> 
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
        <arg choice='opt'><replaceable>timefuzz</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Scan the selection set for runs of commits with identical
comments close to each other in time (this is a common form of scar
tissues in repository up-conversions from older file-oriented
version-control systems).  Merge these cliques by deleting all but the
last commit, in order.</para>

<para>The optional second argument, if present, is a maximum time
separation in seconds; the default is 90 seconds.</para>

<para>The default selection set for this command is =C, all
commits. Occasionally you may want to restrict it, for example to
avoid coalescing unrelated "*** empty log message ***" commits from
CVS lifts.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>mailbox_out</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
        <arg choice='opt'><replaceable>outfile</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Emit a mailbox file of messages in RFC822 format representing
the contents of repository metadata. Takes a selection set; members of
the set other than commits, annotated tags, and passthroughs are
ignored (that is, presently, blobs and resets).  If there is a second
argument, or the first is not recognized as a selection set, it will
be taken as the name of the file to report to; no argument, or one of
'-'; writes to standard output.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>mailbox_in</command>
        <arg choice='opt'><replaceable>infile</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Accept a mailbox file of messages in RFC822 format representing the
contents of the metadata in selected commits and annotated tags. Takes
no selection set.  If there is an argument it will be taken as the
name of a mailbox file to read from; no argument, or one of '-'; reads
from standard input.</para>

<para>Users should be aware that modifying an Event-Number field will change
which event the update from that message is applied to.  This is
unlikely to have good results.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>edit</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Report the selection set of events to a tempfile as mailbox_out does,
call an editor on it, and update from the result as mailbox_in does.
If you do not specify an editor name as second argument, it will be
taken from the $EDITOR variable in your environment.</para>

<para>Normally this command ignores blobs because mailbox_out does.
However, if you specify a selection set consisting of a single
blob, your editor will be called directly on the blob file.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>timeoffset</command>
        <arg choice='plain'>offast</arg> 
        <arg choice='opt'><replaceable>timezone</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Apply a time offset to all time/date stamps in the selected set.
An offset argument is required; it may be in the form [+-]ss,
[+-]mm:ss or [+-]hh:mm:ss.  The leading sign is required to distingush
it from a selection expression.

Optionally you may also specify another argument in the form [+-]hhmm, a
timeone literal to apply.  To apply a timezone without an offset, use
an offset literal of +0 or -0.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>

<refsect2 id='housekeeping'><title>HOUSEKEEPING</title>

<para>These are backed up by the following housekeeping commands, none of 
which take a selection set:</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>help</command></cmdsynopsis></term>
<listitem><para>Get help on the interpreter commands. Optionally follow with
whitespace and a command name; with no argument, lists all commands. '?'
also invokes this.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>shell</command></cmdsynopsis></term>
<listitem><para>Execute the shell command given in the remainder of the line.
'!' also invokes this.  
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>prefer</command>
        <arg choice='opt'><replaceable>repotype</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Report or set (with argument) the preferred type of repository. This
will have two effects.  First, if there are multiple repositories in a
directory you do a read on, reposurgeon will read the preferred one
(otherwise it will complain that it can't choose among them).
Secondly, if you do a write to a directory, it will build a repo of
the preferred type.</para>

<para>If no preferred type has been explicitly selected, reading in a
repository (but not a fast-import stream) will implicitly set it
to the type of that repository.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect2>

<refsect2 id='instrumentation'><title>INSTRUMENTATION</title>

<para>A few commands have been implemented primarily for debugging and
regression-testing purposes, but may be useful in unusual
circumstances.</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis>
    <command>index</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
</cmdsynopsis></term>
<listitem>
<para>Display four columns of info on objects in the selection set:
their number, their type, the associate mark (or '-' if no mark) and a
summary field varying by type.  For a branch or tag it's the
reference; for a commit it's the commit branch; for a blob it's the
repository path of the file in the blob.</para>

<para>The default selection set for this command is =CTRU, all objects
except blobs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>resolve</command>
        <arg choice='opt'><replaceable>selection-set</replaceable></arg>
</cmdsynopsis></term>
<listitem><para>Does nothing but resolve a selection-set expression
and echo the resulting event-number set to standard
output. Implemented mainly for recression testing, but may be useful
for exploring the selection-set language.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>names</command></cmdsynopsis></term>
<listitem><para>List the names of all known branches and tags.
Tells you what things are legal after @.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis><command>version</command></cmdsynopsis></term>
<listitem><para>Report the version of <command>reposurgeon</command>
and the list of version-control systems it directly supports.
</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>verbose</command> 
        <arg choice='opt'>n</arg>
</cmdsynopsis></term>
<listitem><para>'verbose 1' enables progress and messages,
'verbose 0' disables them. Higher levels of verbosity are available
but intended for developers only.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>repeat</command>
        <arg choice='opt'><replaceable>number</replaceable></arg>
</cmdsynopsis></term>
<listitem><para>'repeat 1' causes each 
<command>reposurgeon</command> command to be echoed to standard
output just before its output.  This can be useful in constructing regression
tests that are easily checked by eyeball.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>script</command>
        <arg choice='plain'>filename</arg>
</cmdsynopsis></term>
<listitem><para>Takes a filename argument. Reads each line from the file 
and executes it as a command.</para></listitem>
</varlistentry>
<varlistentry>
<term><cmdsynopsis>
    <command>history</command>
</cmdsynopsis></term>
<listitem>
<para>List the commands you have entered this session.</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2>
</refsect1>

<refsect1 id='limitations'><title>LIMITATIONS AND GUARANTEES</title>

<para>Guarantee: <command>reposurgeon</command> only requires
main memory proportional to the size of a repository's metadata
history, not its entire content history. Blobs are stored on disk.</para>

<para>Guarantee: <command>reposurgeon</command> never modifies
the contents of a repository it reads or deletes any repository. The
results of surgery are always expressed in a new repository </para>

<para>Guarantee: Any line in a fast-import stream that is not a part
of a command <command>reposurgeon</command> parses and
understands will be passed through unaltered.  At present the set of
potential passthroughs is known to include the
<command>progress</command>, the <command>options</command>, and
<command>checkpoint</command> commands as well as comments led by
#.</para>

<para>Guarantee: All <command>reposurgeon</command> operations either
preserve all repository state they are not explicitly told to modify
or warn you when they cannot do so.</para>

<para>Limitation: Because <command>reposurgeon</command>
relies on other programs to generate and interpret the fast-import command
stream, it is subject to bugs in those prograns.</para>

<para>Limitation: Under version-control systems other than git,
fast-import format may not capture the entire repository
state. Presently the only known limitations are:</para>

<itemizedlist>
<listitem>
<para>Under bzr, dumps do not capture information about (a) multiple-author 
commits, (b) bzr custom commit properties (e.g. branch-nick and bugs 
fixed by this change), or (c) empty directories.</para>
</listitem>
</itemizedlist>

<para>Limitation: Subversion/RCS/CVS aren't directly supported because
exporting from them requires fixups of usernames in the committer
information to full email addresses.  Trying to handle that entirely
inside this tool would be excessively messy, so we don't. Instead we
let the user transform repo-command streams and cope with the
export/import separately.</para>

<para>Guarantee: As version-control systems add support for the
fast-import format, their repositories will become editable by
<command>reposurgeon</command>. See the <ulink
url="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools">Git
Wiki tools page</ulink> for a large collection of such tools.</para>
</refsect1>

<refsect1 id='canonicalization'><title>CANONICALIZATION RULES</title>

<para>It is extended that <command>reposurgeon</command> will
be extended with more deletion policies. Policy authors may 
need to know more about how a commit's file operation sequence
is reduced to normal form after operations from deleted commits
are prepended to it.</para>

<para>Recall that each commit has a list of file operations, each a M
(modify), D (delete), R (rename), C (copy), or 'deleteall' (delete all
files). Only M operations have associated blobs.  Normally there is
only one M operation per individual file in a commit's operation
list.</para>

<para>To understand how the reduction process works, it's enough to
understand the case where all the operation in the list are working
on the same file. Sublists of operations referring to different
files don't affect each other and reducing them can be thought
of as separate operations.  Also, a "deleteall" acts a a D for
everything and cancels all operations before it in the list. </para>

<para>The reduction process walks through the list from the beginning
looking for adjacent pairs of operations it can compose.  The following table
describes all possible cases and all but one of the reductions.</para>

<informaltable pgwide='0' frame='all'>
  <tgroup cols='2' align='center'>
    <colspec colname='c1'/>
    <colspec colname='c2'/>
    <tbody>
      <row>
        <entry align='center'>M + D &rarr; D</entry>
	<entry align='left'><para>If a file is modified
	then deleted, the result is as though it had been
	deleted.</para></entry>
      </row>
      <row>
        <entry align='center'>M a + R a b &rarr; R a b + M b</entry>
        <entry align='left'><para>The purpose of this transformation is 
	to push renames towards the beginning of the list,
	where they may become adjacent to another R or C they can 
	be composed with.</para></entry>
      </row>
      <row>
        <entry align='center'>M a + C a b &rarr; C a b + M b</entry>
	<entry align='left'><para>Push copies towards the beginning.</para></entry>
      </row>
      <row>
        <entry align='center'>M b + R a b &rarr; nothing</entry>
	<entry align='left'><para>The rename undoes the
	modification.</para></entry>
      </row>
      <row>
        <entry align='center'>M b + C a b &rarr; nothing</entry>
	<entry align='left'><para>The copy undoes the
	modification.</para></entry>
      </row>
      <row>
        <entry align='center'>D + M &rarr; M</entry>
	<entry align='left'><para>If a file is deleted and modified,
	the result is as though the deletion had not taken place
	(because M operations store entire files, not
	deltas).</para></entry>
      </row>
      <row>
        <entry align='center'>D + {D|R|C}</entry>
	<entry align='left'><para>These cases should be impossible
	and would suggest the repository has been corrupted.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + D a</entry>
	<entry align='left'><para>Should never happen..</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + D b &rarr; nothing</entry>
	<entry align='left'><para>The delete removes the just-renamed file.</para></entry>
      </row>
      <row>
        <entry align='center'>{R|C} + M</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + R b c &rarr; R a c</entry>
	<entry align='left'><para>The b terms have to match for these
	operations to have made sense when they lived in separate
	commits; if they don't, it indicates repository
	corruption.</para></entry>
      </row>
      <row>
        <entry align='center'>R a b + C b c &rarr; C a c</entry>
	<entry align='left'><para>See above.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + D a &rarr; R a b</entry>
	<entry align='left'><para>Copy followed by delete of the source is a rename.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + D b &rarr; nothing</entry>
	<entry align='left'><para>This delete undoes the copy.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + R a c</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
      <row>
        <entry align='center'>C a b + R b c &rarr; C a c</entry>
	<entry align='left'><para>Copy followed by a rename of the
	target reduces to single copy</para></entry>
      </row>
      <row>
        <entry align='center'>C + C</entry>
	<entry align='left'><para>No reduction.</para></entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

</refsect1>

<refsect1 id='recovery'><title>CRASH RECOVERY</title>

<para>This section will become relevant only if 
<command>reposurgeon</command> or something underneath it in the
software and hardware stack crashes while in the middle of writing out 
a repository, in particular if the target directory of the rebuild is
your current directory.</para>

<para>The tool has two conflicting objectives: on the one hand, we
never want to risk clobbering a pre-existing repo.  On the other hand,
we want to be able to run this tool in a directory with a repo and
modify it in place.</para>

<para>We resolve this dilemma by playing a game of three-directory monte.</para>

<procedure>
<step><para>First, we build the repo in a freshly-created staging
directory.  if your target directory is named
<filename>/path/to/foo</filename>, the staging directory will be a
peer named <filename>/path/to/foo-stageNNNN</filename>, where NNNN is
a cookie derived from <command>reposurgeon</command>'s process
ID.</para></step>

<step>
<para>We then make an empty backup directory.  This directory will
be named <filename>/path/to/foo.~N~</filename>, where N is incremented
so as not to conflict with any existing backup drectories.  
<command>reposurgeon</command> never, under any circumstances.
ever deletes a backup directory.</para>

<para>So far, all operations are safe; the worst that can happen up to
this point if the process gets interrupted is that the staging and
backup directories get left behind.</para>
</step>

<step><para>The critical region begins. We first move everything in the
target directory to the backup directory.</para></step>

<step><para>Then we move everything in the staging directory to the
target.</para></step>

<step><para>We finish off by restoring untracked files in the target
directory from the backup directory. That ends the critical
region.</para></step>
</procedure>

<para>During the critical region, all signals that can be ignored are
ignored.</para>
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>

<para>Eric S. Raymond <email>esr@thyrsus.com</email>; project page at <ulink
url='http://www.catb.org/~esr/reposurgeon'>http://www.catb.org/~esr/reposurgeon</ulink>.</para>
</refsect1>
</refentry>
